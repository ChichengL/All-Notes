**Star法则：情景（Situation），任务（Task），行动（Action），结果（Result）** 


## 你在快手做过哪些项目
**为什么从快手离职**
1. 当时打算就是干三个月左右，为后面大三的实习做一些铺垫
2. 正值要回学校参加补考+自己打算休息一段时间，感觉自己长期不回不太好
3. 自己还是想去字节这样的大公司去看看，虽然快手也是大厂了，但是每个公司是有不同的特点的，而且字节也是我开始就想去的公司。
**你在快手做了什么**？
我在快手主要是做客服平台web端的功能迭代开发。
参与的需求有，打标优化，chat工作台状态条优化等
**你实习遇到的最大挑战是什么？**
遇到的困难并不是太大，稍微在前期没有头绪的是打标优化的项目，参与技术评审时，对于这个平台不是很熟悉，当时遇到是需要，对树形结构保持展开。因为每一次更新工单，都会导致工单列表的刷新，工单列表刷新之后对于树形而言是默认都不展开或者都展开的。
然后我这边开始认为是需要通过点击获取点击的某一个工单项，并且记录下来，如果进行打标操作之后，工单刷新，然后默认就全部收起，我开始认为是需要获取到对应的DOM元素然后让他scrollIntoview来实现重新出现到列表中。
但是实际上可以通过修改节点的expanded属性来控制展开。这个操作是放在nextTick里面的，因为这个树形结构和一个数组相关联，数组变动，树形结构默认会变为收起，这里当DOM更新之后再去操作dom结构，因为不这样，反而同步去操作DOM的话，大概率这个DOM操作的行为会被后续数据更新导致的DOM更新所覆盖。

### 打标优化
#### 业务背景
客服工作台——工单工作台涉及到大量工单，需要客服处理，但是之前的现状是，有一个小旗帜标识不同的工单，这个小旗帜无法自定义，且只有三种颜色，产品根据客服的反馈做了调研，后续得到需要`自定义+快速打标`的需求迭代。
#### 业务方案
将以前一维的数组变为一二维交替（不进行旗帜分组时是一维，进行旗帜分组时是二维，这个二维是通过树形解决的。）
在二维列表中对每一个工单列表项支持`contextmenu`事件支持右键快速唤起打标列表。
同时在工单列表支持一个对当前客服旗帜的自定义更改。
>可拓展：鼠标滚轮事件是什么`@wheel`，鼠标移动事件`@mousemove`

#### 业务难点：
在工单列表右侧存在一个工单详情，里面可以对工单进行一些操作，比如备注，更改工单状态、流转工单等等操作。
这里更改工单状态之后，会有一个消息推送过来，这里使用的link（websocket的一个应用），通过link接收到消息的推送，从而直接改变工单列表中某一个工单的状态。
这里做了websocket来获取更新，因为主从延迟，在发送请求之后再立刻去请求得到的数据为脏数据，因此采用乐观更新

>**提问**：为什么不直接通过获取工单列表的接口再次获取。
>因为这里获取的工单消息并没有及时更新，因为这个工单数据和多个平台绑定，服务端更新时间长达两三秒，导致一旦通过推送发过来的消息立即去请求，得到的数据并不是一致的。（这个是对接的后端说的有时延的问题）。
>
>**继续提问**：那么如何去保障数据一致性。
>对于前端来说，可以通过确认唯一的link，避免多个link向服务端推送消息导致数据错乱（真正业务中没有向服务端推送的东西，我接触到的）。将全局唯一的link挂载到window上。
>后端的话可以使用。
> - 消息队列比如Kafka之类的将存储的信息发送到消息队列中然后另一个订阅的系统对这个做处理
> - 可以采用redis来进行缓存。
> - 还有采用锁防止同一条数据被同一时间篡改。
>   **提问**：websocket断开如何处理
>   断开之后，是存在重连机制的。且每次重连都会在控制台输出，以便开发人员监听，且做了相对应的埋点处理。
至于为什么使用websocket而不是用轮询，是因为我们已经有一套websocket的方案了，已经和后端达成共识，不用再去封装。






这里我有做得不好的点，因为我是有一个调用获取分组的接口，然后监听的是工单变化，就调用这个接口。
产生的影响：频繁调用接口（这里做了防抖处理）。在灰度使用中出现过，工单的标签更新了，但是工单列表中的没有更新，就是因为上述提到的问题（工单列表第一时间更新，但是数据库中的数据并不是同步更新，导致获取的数据和目的数据不一致）

>**提问**:工单是可以处于多个状态的。那么有没有什么状态回滚的方案，比如一个工单需要ABCDE客服处理（实际上不合理，因为客服人力也是一个很大的资源消耗），B手滑不小心通过审核，需要从C中重新拿回工单应该如何做。
>**答**：补救措施：这里可以定制化开发一个按钮，对于状态有误的工单，可以通过按钮+弹窗（申请理由）拿回工单，同时在弹窗完成之后，发起的请求中使用锁，对于请求的工单进行锁定，防止在这个过程中其他人操作，等待拿回之后，再将锁解除）
>预防措施：在进入下一个流程时，出现弹窗，确认是否进入下一个流程，以避免工单的意外流出。


### Chat工作台状态条优化
#### 业务背景
用户与商家沟通出现矛盾时，需要客服处理，但是每个客服都有自己的技能组，每个技能组都有闭线时间，如果到达闭线时间的话，那么客服就相当于下班了，但是客服无法感知当前技能组是否有排队的人数（需要客服介入的用户），造成用户体验感丢失。
#### 业务方案
这里就做了一个排队人数的展示+达到闭线时长且有人等待的情况下出现弹窗的小需求

#### 业务难点
这里的难点主要是一个浏览器相关的问题。
对于chat工作台的状态条部分，是有关当前客服的状态的：工作、小休、其他，这个状态通过接口获取。这里也可以通过点击各个状态的面板进行切换状态，问题就出现在切换状态这里。
当客服人员，新开其他窗口，然后隔几分钟~十几分再次切回页面，状态丢失，这里涉及到状态的改变，然后就使用watch监听状态变化，如果是新值是undefined就再次调用接口。

#### 业务收益
提高需客服处理的用户体验感。
但是有些点没有考虑到，可能客服即将下班，但是处理这个用户如果时间过长，客服体验感差。
有另外的方案考虑：客服是存在两个轮次的，如果即将下班就不会进线即将闭线的客服，但是这样可能导致用户等待时间过长，这里需要一个好的调度算法，或者是，当接近下班时间在处理这个的客服可以转接给其他已经上班的客服技能组，然后获取对应的上下文，以解决用户和客服的问题。（这里有转接功能，可以讲客服手持的人员转接到其他人上，但是这个是不能获取上下文的，那么这里有一点缺陷，同时这个接入了ai，当ai不能解决就会有转人工的操作）
### 代客新增/修改poi
#### 预计收益
![](https://files.catbox.moe/uru74x.png)
大概节约 0.47人/日  以6月 13单/日的流转处理量折算。
#### 需求背景
商家可以通过电脑端或手机端，使用【店铺装修】、【商家认领门店环节-自助新增/修改POI】的能力。但是实际服务测的问题监控场景中发现，由于功能上线导致poi中台不在承接人工反馈需求，且客服不支持代客修改，即不能通过客服平台为商家的反馈去做对应的修改，需要联通两个平台，导致用户进线后体验较差
 
#### 技术方案
在工单工作台实现一个特殊回执，包括对poi信息的新增/修改 +地图组件的显示和反显，这个地图的需求是要和poi中台那边对齐，其次就是为了让输入地址之后能够在地图上显示的可视化以更多维的角度对地址的确认。
高德api中的`getLocation和getAddress`分别获取经纬度和地址
我个人的看法：对这个需求感到有点不合理，这个poi中台应该兼顾接受反馈的渠道，但是所有的人工反馈都走的客服通道，导致客服平台需要做出兼容，以便客服人员对poi信息的处理。
## 其他

一、轮询（Polling）
1. 短轮询（Short Polling）
- ​**实现方式**：客户端定时（如每秒）向服务器发送请求，无论是否有数据更新。
- ​**优点**：
    - ​**兼容性高**：所有浏览器和服务器均支持（基于 HTTP）。
    - ​**实现简单**：无需特殊协议或库。
- ​**缺点**：
    - ​**高延迟**：数据更新取决于轮询间隔，实时性差。
    - ​**资源浪费**：频繁请求导致带宽和服务器资源浪费。
    - ​**并发压力**：高频率请求可能引发服务器过载。

​2. 长轮询（Long Polling）

- ​**实现方式**：客户端发送请求后，服务器保持连接直到有新数据或超时，再重新发起请求。
- ​**优点**：
    - ​**实时性较好**：减少无意义请求，数据到达后立即返回。
    - ​**节省带宽**：相比短轮询，减少无效请求次数。
- ​**缺点**：
    - ​**服务器开销**：大量挂起连接占用服务器资源。
    - ​**实现复杂**：需处理连接超时和重连逻辑。
    - ​**潜在延迟**：超时后仍需重新建立连接。

---

 ​二、WebSocket**

- ​**实现方式**：基于 TCP 的全双工通信协议，建立持久连接后，客户端和服务器可随时双向传输数据。
- ​**优点**：
    - ​**实时性强**：数据即时推送，毫秒级延迟。
    - ​**高效通信**：无 HTTP 头开销，节省带宽。
    - ​**低服务器压力**：一个连接支持持续通信，减少并发请求。
- ​**缺点**：
    - ​**兼容性限制**：需浏览器支持 WebSocket（IE10+），部分防火墙可能拦截 WebSocket 连接。
    - ​**实现复杂**：需处理连接状态维护、心跳检测、重连机制等。
    - ​**协议升级**：需服务器支持 WebSocket 协议（如 Node.js 的 `ws` 库）。

---

 ​**三、对比总结**

|​**对比维度**​|​**短轮询**​|​**长轮询**​|​**WebSocket**​|
|---|---|---|---|
|​**实时性**​|低（依赖轮询间隔）|中（数据到达后立即响应）|高（即时推送）|
|​**带宽消耗**​|高（频繁请求）|中（减少无效请求）|低（无 HTTP 头，持久连接）|
|​**服务器压力**​|高（高并发请求）|中（挂起连接占用资源）|低（单连接复用）|
|​**兼容性**​|所有浏览器|所有浏览器|IE10+ 及现代浏览器|
|​**实现复杂度**​|简单|中等|复杂|
|​**适用场景**​|低频更新（如天气预报）|中等实时性（如聊天室）|高频双向通信（如实时游戏）|

---

 ​**四、选型建议**

1. ​**优先 WebSocket**：
    
    - 需要高频双向通信（如在线协作编辑、股票行情）。
    - 要求低延迟和高效资源利用（如视频弹幕、实时监控）。
    - 示例代码：
        
        javascript
        
        ```javascript
        const socket = new WebSocket('ws://api.example.com');
        socket.onmessage = (event) => {
          console.log('Received:', event.data);
        };
        ```
        
2. ​**考虑长轮询**：
    
    - 需兼容旧版浏览器（如 IE9）。
    - 实时性要求一般且更新频率较低（如邮件通知）。
    - 示例代码：
        
        javascript
        
        ```javascript
        function longPoll() {
          fetch('/api/data').then(response => {
            processData(response);
            longPoll(); // 递归调用维持长轮询
          });
        }
        ```
        
3. ​**避免短轮询**：
    
    - 仅在极低频更新或快速验证原型时使用。

---

**五、优化策略**

- ​**WebSocket 增强**：
    - ​**心跳机制**：定时发送 ping/pong 维持连接。
    - ​**重连逻辑**：监听 `onclose` 事件并自动重连。
    - ​**降级方案**：不支持 WebSocket 时切换为长轮询。
- ​**轮询优化**：
    - ​**动态间隔**：根据数据更新频率调整轮询间隔。
    - ​**增量更新**：仅请求变化部分数据（如使用 `Last-Modified` 头）。

**问题**：你提到你们部门做的数据埋点、监控这些可以聊聊吗？
答：我本身需求上是没有做埋点、监控相关的，我们组内有专门的人去负责埋点、以及监控页面的搭建，这个监控主要是监控异常，包括卡顿、报错、白屏等，但是异常卡死应该是没有做埋点收集的，因为当时是正在讨论这个事情的可行性，包括c端的埋点。
这里对于报错主要有js报错和异步报错。js报错的话可以在`window.onerror`来实现对报错的监听，对于异步报错，可以通过全局挂载`unhandledrejection`


面试问题：
## 菜逼遗留问题解决
1. history和hash的区别
2. Es5 6 7 8 9 10 11 12 13 14 15 16 17
3. 唤端
4. webpack+vite
5. 浏览器渲染原理
6. 浏览器缓存
7. 性能指标
8. v2-v3 v3响应式 
9. css 优先级
10. undefined null
11. == ===
12. Promise 
    1. 取消一个Promise，AbortControl
13. 事件循环
14. ipc 通信，进程间通信
15. websocket
16. SSR ISR CSR SSG
17. SSE 
18. chatGPT 流式传输
19. 小程序启动优化策略
20. YJS OT CRDT
21. token 无感刷新
22. Get Post 区别
23. JS 基本数据类型
24. 预检请求
25. 跨域才会有预检请求吗？
26. 什么是跨域？
27. 组件间通信问题
28. 为什么webpack万物皆可模块
29. url-loader干什么的？
30. vite为什么快？
31. css主题切换方案
32. 闭包是什么？优缺点？
33. https的作用
34. https是非对称加密，如何交换密钥呢？
35. SSL TLS 握手分别几次？如何做的？
---
## 点对点硬撼
1. JS 基本类型
>[!info]
>1.七种基本数据类型 
>- **布尔值Boolean**: true & false
>- **null**, 一个表明 null 值的关键字。JS是大小敏感的，因此 null Null NULL 完全不同
>- **undefined**
>- **数字 Number**
>- **字符串 String**
>- **代表 Symbol** 实例是唯一不可变的类型
>- **任意精度的整数 BigInt**
>2. 引用类型 **Object**
>- Object
>- Array
>- Function
>- Set
>- Map
>- ...
1. == ===
>[!info]
>[[类型的隐式转换]]
1. 事件冒泡和捕获，JS事件流
>[!info]
>xxx
1. CSS 水平垂直居中的方式
2. https比http多了什么？https的大致原理
3. https的加密过程，对称加密和非对称加密算法的流程是什么？
4. webpack/vite的最主要区别
5. vite为什么比Webpack快，为什么？冷启动原理是什么？
6. vite在生产环境下是用什么打包？
7. 开发到提交用git的一般步骤到常见命令
8. 了解跨域吗？什么是跨域？如何解决?
9. **数组扁平化，合法括号**
10. **异步任务看代码说输出，JS作用域问题，两数之和，高精度加法**
11. http缓存策略
12. max-age是什么？值是什么？
13. cache-control字段了解吗？
14. expire听说过吗？
15. max-age和expire的联系
16. https安全在什么地方
17. 对称加密和非对称加密分别加密的是什么内容
18. 最近在学什么前端技术？
19. React和Vue之间在响应式上实现的差异是什么？
20. React和Vue的使用上，学习阶段上最明显的差异
21. 函数式编程
22. React进行虚拟元素对比，大概的流程是什么？
23. 针对什么资源进行强缓存？
24. 浏览器事件循环机制
25. 如何判断一个任务是宏任务还是微任务
26. **最长回文子串**
27. CSS中的flex布局，一般会用到哪些应用场景？会用到哪些业务属性？
28. opaticy: 0; visibility: hidden; display: none有什么区别？如果要响应鼠标的事件的话，这三个属性设置了都可以触发吗？
29. `i = 1; let i = 2;`在哪行报错？
30. **异步输出**
31. 了解TS吗？
32. webpack plugin loader
33. 怎么优化首屏加载速度？
34. **三道大数相加并发限制的异步解调器，同时只能运行两个任务，怎么写？实现一个 Event 事件观察者的类**
35. 发布订阅模式
36. 不同设备的兼容性是怎么做的？
37. 媒体查询？
38. cookie session 区别
39. 为什么需要有sessionID
40. 没有sesssionId会出现什么？
41. 说一下localStorage, sessionStorage
42. 怎么设置一套用户的权限管理系统？根据用户权限判断用户是否能登录，以及登录后能看到的路由和同一个界面不同用户可能会看到不同的内容？在做不同用户同一页面展示不同内容时，怎么封装出来一个通用的设计模式？
43. **LRU缓存**
44. **loadsh.get()**
45. **深拷贝**
46. **岛屿数量，最大岛屿面积**
47. Formily原理
48. 常用的hooks
49. setTimeout和setInterval倒计时是精确的吗
50. 有什么更好的倒计时的实现方式？
51. 浏览器进程 线程
52. 结合线程讲事件循环
53. 网络进程和异步http线程关系
54. **函数柯里化**
55. **括号生成**
56. [字节前端商业化一二三面面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/411136220913299456?sourceSSR=search)


