
# 面试准备

- [ ] nodejs如何利用多核cpu，原理？


wxg面试题目
- [x] [有效的括号](https://leetcode.cn/problems/valid-parentheses/) 
      2024-5-10 19:00一次 
      2024-5-12 10:18二次
- [ ] [寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) 
      二分 2024-5-10-21:13 需要再来两次,二分和快慢指针
      2024-5-12 10:28 二分 && 快慢指针
- [ ] [路径总和](https://leetcode.cn/problems/path-sum/)2024-5-10 21:22
      2024-5-12 10:38 dfs
- [ ] [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)2024-5-10 21:47
- [ ] [LRU 缓存](https://leetcode.cn/problems/lru-cache/) 2024-5-10 22:17
- [x] [括号匹配](https://leetcode.cn/problems/IDBivT/description/) 2024-5-10 22:19
- [ ] [打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)，打家劫舍全系列刷一遍 2024-5-11 10:51一次
- [ ] [三数之和](https://leetcode.cn/problems/3sum/)2024-5-10 22:32
- [ ] hardman
- [ ] 36匹马，6个赛道塞多少次能决出前三
- [ ] 多线程的应用场景，js的
- [ ] [最长字符串链](https://leetcode.cn/problems/longest-string-chain/description/)
- [ ] Hardman  两次（还需要复习一两次）


Hardman
题目
```js
new HardMan("jack");
// // > I am jack

new HardMan("jack").rest(2).learn("computer")
// > I am jack
// 等待2秒
// > Start learning after 2 seconds
// > Learning computer

new HardMan("jack").restFirst(5).learn("chinese");
// 等待5秒
// > Start learning after 5 seconds
// > I am jack
// > Learning chinese
```
实现一个这样子的


思路分析，对于这个题目，应该是将打印放入宏任务队列中，不能一开始就执行。
同时可能存在多个任务队列，因此需要维护一个任务队列
```js
this.tasks = [()=>console.log(name)]
```
初始值传入一个name，然后使用宏任务队列进行打印
```js
run(){
	setTimeout(async()=>{
		for(let task of tasks){
			await task()
		}
	},0)
}
```

然后在初始化的时候就同步调用

现在开写同步加入到队列的方法
```js
rest(time){
	this.tasks.push(this.sleep(time));
	return this;
}
learn(time){
	this.tasks.push(()=>console.log(`Learning ${time}`))
	return this;
}
resetFirst(time){
	this.task.unshift(this.sleep(time));
	return this;
}
sleep(time){
	return new Promise(resolve=>{
		setTimeout(()=>{
			console.log(`Start learning after ${time} secons`);
		},time*1000);
	})
}
```
为什么要使用await ，不使用promise+await就比较难阻塞
```js
class HardMan { 
    constructor(name) { 
        this.name = name;
        this.tasks = [() => console.log(`I am ${this.name}`)]
        this.run()
    }
    rest(seconds) {
        this.tasks.push(this.sleep(seconds))
        return this; 
    }
    restFirst(seconds) { 
        this.tasks.unshift(this.sleep(seconds))
        return this; 
    }
    learn(something) {
        this.tasks.push(() => console.log(`Learning ${something}`))
        return this;
    }
    sleep(time) {
        return () => new Promise((resolve) => {
            setTimeout(() => {
                resolve(console.log(`Start learning after ${time} seconds`));
            },time*1000)
        })
    }
    run() {
        setTimeout(async() => {
            for (let task of this.tasks) {
                await task();
            }
        })
        return this;
    }
}
```
完整代码参上



企业微信面试题
- [x] [比较版本号](https://leetcode.cn/problems/compare-version-numbers/)
- [x] [两数之和](https://leetcode.cn/problems/two-sum/description/)
- [ ] 交换最大元素
- [x] http版本
- [ ] http缓存
- [ ] uniapp原理
- [ ] 微信小程序模型
- [ ] 两者的区别
- [ ] mvvm模型
- [ ] 虚拟dom
- [ ] 懒加载
- [ ] 浏览器输入到渲染流程
- [ ] expires
- [ ] 字符串如何比较大小
- [ ] 回流重绘
- [x] tcp，udp的区别 ，tcp可靠的方法
- [ ] tcp三次握手，还需要复习（大概差不多了）
- [ ] set底层实现——哈希
- [ ] 大文件分片上传，如果有多台服务器，一个文件的不同片传到了不同服务器上，该怎么做合并？
- [ ] webSocket原理
- [ ] 两个队列实现栈
- [ ] canvas指纹追踪，css键盘安全，xss
- [ ] 






webScoket原理
1. **握手阶段**:
    
    - **客户端发起连接请求**：WebSocket连接的建立始于一个类似HTTP的请求。客户端通过HTTP的Upgrade头部字段向服务器发起一个特殊的HTTP请求，请求中包含Upgrade头部，其值为`websocket`，以及Connection头部设置为`Upgrade`，表明客户端希望将此HTTP连接升级为WebSocket连接。此外，请求中还包含Sec-WebSocket-Key、Sec-WebSocket-Version等头部，分别用于提供安全密钥和指定WebSocket协议版本。
    - **服务器响应确认**：服务器收到请求后，如果支持WebSocket连接，会返回一个HTTP响应状态码101 Switching Protocols，表示服务器同意将连接协议切换为WebSocket。响应中也会包含Sec-WebSocket-Accept头部，该头部的值是根据客户端提供的Sec-WebSocket-Key计算得出的，以此作为握手的确认。
2. **数据传输阶段**:
    
    - 一旦握手成功，HTTP连接就被转换为一个持久的WebSocket连接，之后的数据交换不再使用HTTP协议，而是直接基于TCP连接进行。WebSocket协议定义了自己的帧格式，用于封装传输的数据，这些帧可以包含文本或二进制数据。
    - WebSocket连接是全双工的，这意味着客户端和服务器都可以在任何时候独立地发起数据传输，无需等待对方的请求或响应，大大提高了交互的实时性。
3. **心跳与控制消息**:
    
    - 为了维护连接的活跃状态，WebSocket连接可能会周期性地发送心跳包，这是一种简单的控制消息，用于检测连接是否仍然活跃。
    - WebSocket还支持其他控制帧，如用于关闭连接的帧，其中可以携带关闭状态码和原因说明。
4. **关闭连接**:
    
    - 当任一端决定结束会话时，可以通过发送一个包含关闭指令的控制帧来关闭连接。双方会交换关闭帧，最终按照TCP的流程优雅地关闭连接。

WebSocket的这些机制使得它非常适合实时通信的应用场景，如在线聊天、游戏、股票报价、协同编辑等，因为它能提供比传统Ajax轮询或长轮询更为高效和实时的数据交换方式。


```js
class myStack{
    constructor() {
        this.q1 = []
        this.q2 = []
    }
    push(x) {
        this.q1.push(x)
    }
    pop() {
        if (this.q1.length === 0) { 
            return null;
        }
        while (this.q1.length > 1) { 
            this.q2.push(this.q1.shift())
        }
        const res = this.q1.shift()
        while (this.q2.length > 0) { 
            this.q1.push(this.q2.shift())
        }
        return res
    }
}

const stack = new myStack()
stack.push(1)
stack.push(2)
stack.push(3)
console.log(stack.pop()) // 3
console.log(stack.pop()) // 2
console.log(stack.pop()) // 1
console.log(stack.pop()) // null
```