**Star法则：情景（Situation），任务（Task），行动（Action），结果（Result）** 

### HTML/CSS
**CSS的盒子模型工作原理且如何在不同的浏览器中确保一致性?**
盒子模型，每个HTML元素都被当作一个矩形的盒子，由内到外

内容区域、内边距、边框、外边距。
标准盒子模型：默认情况下，`width`和`height`只包含内容区域的宽高，不包括内边距和边框。实际占用空间的计算公式是：
```css
总宽度 = width + padding-left + padding-right + border-left + border-right 总高度 = height + padding-top + padding-bottom + border-top + border-**bottom**
```
怪异盒子模型（ie盒子模型）：在这种模型中，`width`和`height`包括了内容区域、内边距和边框的总和。这意味着内边距和边框会从设置的`width`和`height`中扣除。
通过设置`box-sizing: border-box;`可以切换到这种模型。
一致性可以通过`box-sizing:border-box`来让盒子模型在所有浏览器中表现一致。

**谈谈你对css预处理器的理解，如何提高开发效率**
CSS预处理器的特点：变量（CSS也有）、嵌套（CSS新版也有）、继承与混合、函数运算、模块化

知道BFC吗？简单说一下。
BFC是一个块级格式化上下文，这个区域内的渲染不会影响其他区域。
如何创建：
- overflow不是visible，float非none，position非absolute
- display为flex或者grid
- 根元素
作用：消除浮动，导致的定位问题，防止外边距塌陷，控制绝对定位元素位置的计算。



### ES6有哪些新特性：
let/const、箭头函数和Class类、模版字符串、解构赋值和展开运算符、默认参数、、for ... in/of 循环、map/set数据结构、Promise、Symbol
延展let/const/var有什么区别：var 是es6之前声明变量的操作符，let/const是es6及之后的。
他们的区别：
**var**
var声明的变量存在变量提升，这个变量提升在function声明函数时也会存在。
var声明的变量挂载到window（全局对象）上的，且不会被局部作用域所框束。

所以会存在一些问题比如：
```js
for(var i = 0; i < 10; i ++){
    setTimeout(()=>{console.log(i)});
}
```
这个打印10个10；
要想解决也很简单：1. 换为let，2.使用IFFE将变量保留

原因：每次循环都是一个局部作用域，因此每次的i是不同的，只在自己的作用域有效，所以打印出的值是当前作用域的值。（对于换为let）
对于换为IFFE，是因为相当于是一个闭包，保留了当前的值

**let/const**
let声明的变量可变，const声明的变量不可变。这里的可变与不可变并非绝对，对于const声明的基本类型是不可变的，而对于const声明的引用类型是可以变化的。
且这两个都会有TDZ（暂时性死区的存在），如果在声明之前使用就会报错。

**箭头函数和Class**
这两者的出现是为了解决函数的二义性，即可做函数也可做类。
箭头函数没有自己的this只能使用上一层的this
```js
const a = ()=>{
    console.log('a',this);
}
function b(){
    console.log('b',this);
}
a();
b();
```

在浏览器环境，两个打印的都是`window`,但是在node环境a打印的空对象，b打印的window。
因为a调用的时候没有自己的this，只会从外部上下文环境中获取，在nodejs中顶层代码的this指向空对象。对于普通函数的 `this` 取决于函数的调用方式。在顶层代码中直接调用 `b()`，`this` 指向的是全局对象。

class的作用：封装、继承、多态（面相对象的特性）

**模版字符串**
可以支持换行+字符占位
其大概实现：
```js
const year = '2024'
const month = '08'
const day = '19'
function render(str){
    return str.replace(/\$\{(\w+)\}/g,(match,key)=>{
        return eval(key);
    })
}
console.log(render('${year}-${month}-${day}'));
```

**解构赋值和展开运算符**

解构：数组解构，对象解构
```js
const arr = [1,2];
const [a,b] = arr;

const obj = {name:'1',age:18};
let objClone = { ...obj };
```
这里展开运算符可以做浅拷贝
浅拷贝的其他实现方案：Object.assign，手动实现浅拷贝，数组的slice，Array.from，concat方法也可以实现浅拷贝
拓展：深拷贝和浅拷贝区别
浅拷贝只拷贝数据，如果有引用类型，会导致共用一个引用类型，引发数据混乱的问题。
深拷贝实现
```js
const deepCopyOptimization = (obj) => {
    const cache = new WeakMap();
    const copy = (obj) => {
        if (typeof obj !== 'object' || obj === null) {
            return obj;
        }
        if (cache.has(obj)) {
            return cache.get(obj);
        }
        const newObj = Array.isArray(obj)? [] : {};
        cache.set(obj, newObj);
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                newObj[key] = copy(obj[key]);
            }
        }
        return newObj;
    }
    return copy(obj);
}
```
这个没有考虑map，set，symbol等数据结构。
获取Symbol需要使用`Object.getOwnPropertySymbols(obj)`

for...in/ of
for...in是用来遍历键的，针对于对象。
for...of是用来获取值的，只有实现了`Symbol.iterator`的才可以使用for...of来获取值
对象是不能使用for...of来获取值的，但是可以手动做到
```js
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        for(let key in this){
            yield key;
        }
    }
}
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        // for(let key in this){
        //     yield key;
        // }
        const keys = Object.keys(this); // 获取对象自身的所有键
        let index = 0;
        return {
            next: () => {
                if (index < keys.length) {
                    return { value: this[keys[index++]], done: false };
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
    }
}
for(let key in obj3){
    console.log(key)
}
for(let key of obj3){
    console.log(key)
}

```
这样for...in/of都可以遍历对象了。


**Promise**
一文弄懂[Promise](http://www.chichengl.xyz/archives/yi-wen-nong-dong-promiseji-qi-shou-xie)
async/await 可以看作是promise+generator的语法糖。

### Vue相关
Vue2和Vue3的区别在哪里：
- api——组合式与选项式：更加细腻的api，如shallowRef
- 响应式的重构
   - vue2：defineProperty
   - vue3：proxy
- 内置组件的变化
   - **新增了：Fragment、Teleport（vue3.2及之前的版本是有内存泄露的风险）、Suspense**
- **生命周期的变化**
- diff算法的优化
- **类型安全**
   - vue3支持了ts
- **模块化**
   - vue2默认是webpack
   - vue3默认是vite
- **vue3新增了tree-shaking**

响应式本质是：数据与函数的联动，数据变化催发函数执行的过程。
响应式的实现：defineProperty，Proxy，观察者模式+发布订阅

**vue3的组合式api相较于vue2的选项式api有什么优势**
更好的代码组织和逻辑复用，可以将相关的函数集中放置。
更好的类型支持。
更好的treeShaking支持。

**VueRouter有了解吗？VueRouter有两种模式，hash模式和history模式**
router和route的区别：
router：是操作路由的对象，可以通过router进行函数式对路由进行函数式操作
route是路由元信息，存储着当前路由下的query等信息。
hash模式：Hash模式使用URL的`#`符号（也称为“锚点”）来模拟不同的路径。当哈希值改变时，浏览器的`hashchange`事件会被触发，VueRouter通过监听这个事件来切换视图。
优点：兼容性过更强，不需要服务端的配置，因为hash部分不包含在http请求，前端就可以处理
缺点：url不美观，seo支持不友好。

history模式：History模式利用HTML5的`history.pushState`和`history.replaceState` API，在VueRouter的History模式下，URL是“真实的路径”，例如`http://example.com/home`，而不是通过哈希来模拟路径。
优点：SEO友好，更强的历史管理，push等操作可以被历史记录导航所使用（浏览器的前进后退）
缺点：需要服务端搭配，旧版浏览器不兼容

**了解过Vue-cli，还了解过webpack和vite？**
vue-cli的是什么，vue-cli是一个基于webpack的脚手架，便于快速搭建vue等项目。

webpack和vite都是打包构建工具，webpack出现时间更早，生态更加成熟，但是是基于js所编写，其天然对js有打包能力，其他对图片的打包需要通过相对应的loader来实现。
vite出现时间稍晚，但是其打包速度以及热更新速度很快，其生态也愈发完善。

**vite为什么比webpack更快，有什么优势?**
Vite基于rollup+esmodule，在开发阶段的打包构建，是“no bundle的”没有打包这个概念，让浏览器全权决定打包，其次他的热更新是定点更新，一个文件更新，只有其他依赖了这个文件的文件才会一同更新，而非类似于webpack全量的再去递归寻找依赖关系进而更新。


**Vue的VNode了解吗，什么是虚拟DOM，虚拟DOM有什么好处？**
虚拟DOM就是以一个对象来描述DOM节点的信息，VNode其实就是vue中的虚拟DOM，通过操作虚拟DOM替代直接操作浏览器中的DOM。

虚拟DOM的好处：
1. 多次操作DOM的情况下，会引发多次回流、重绘，但是多次操作虚拟DOM再一次操作真实的DOM是比较好的。
2. 跨平台，虚拟DOM是一层抽象结构，可以实现跨平台的渲染。
3. 更高效的更新，通过diff算法，来比较前后两次虚拟DOM的差异，并值更新那些实际发生变化的部分，避免了全量重回，提高了性能。

**什么是Vue中的“依赖收集”？它是如何工作的？**
Vue中的依赖收集是vue实现响应式的核心部分，通过它，Vue能够自动追踪哪些组件或函数依赖于某些响应式数据，从而在数据变化时自动更新相关视图。
依赖收集的工作机制主要依赖于`Object.defineProperty`（Vue2）或`Proxy`（Vue3）。当我们在组件中访问某个响应式数据时，Vue会拦截这个数据的读取操作（通过`getter`），将当前的组件或计算属性函数作为“订阅者”记录下来，添加到该数据的依赖列表中。这些“订阅者”通常由Vue内部的“Dep”类或“ReactiveEffect”类管理。

当数据发生变化时，Vue会通过`setter`触发通知，遍历依赖列表中的所有“订阅者”，并执行它们的更新操作。这样，只有与变化数据相关的部分组件或计算属性会被重新计算或重新渲染，提升了应用的性能和响应速度。



### 计算机基础+计网
**从输入url到展示页面的过程**

1. 先判断输入内容是否为有效的网址，如果不是按照浏览器设定的搜索引擎进行搜索，如果是那么就当作地址去查找IP。
2. 通过域名解析系统DNS，把域名转化为DNS，这里可以通过标签`<link rel="dns-prefetch" href="https://github.com"></link>`提前解析。这里拿到IP地址会先看本地的IP地址缓存，如果没有再通过DNS服务器去查找。查找有多种方式，有直接查找到根域名服务器的**递归查询**，也有每一次查询之后返回给客户端下一步需要查询哪个的DNS服务器的**迭代查询**。
3. 拿到IP地址之后就开始建立TCP连接：包括3次握手和四次挥手（详细可看<mark style="background: [[FFB8EBA6]];">部分计网</mark>）。这里TCP连接也可能是长链接。
4. 发送http请求，服务器处理请求并响应。
5. 浏览器接收到处理响应：
	1. 解析HTML建立DOM树
	2. 样式解析——解析CSS生成CSSOM
	3. 布局——计算布局，生成布局树
	4. 分层——渲染进程生成图层树
	5. 图层绘制
	6. 栅格化

这里相关的有重排和重绘；
重排：更新了元素的几何属性，如高度等，触发重新布局（从样式解析重走一遍），**重排需要更新完整的渲染流水线，所以开销也是最大的**
![](https://files.catbox.moe/yiyvd4.png)

重绘：更新的元素的背景，比如透明度变为0等情况，**重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**
![](https://files.catbox.moe/0c95p8.png)
更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做**合成**。比如使用transform，可以避开重排和重绘
![](https://files.catbox.moe/252cvp.png)


**说说你对渲染机制的理解，以及在优化页面渲染时你会考虑哪些因素**
尽可能减少重排重绘，比如减少DOM操作合理的使用动画之类的。
使用GPU加速，或者是在requestAnimationFrame来控制函数的执行
异步加载js，对于script标签使用
懒加载图片，减少不必要的DOM，避免过深的嵌套DOM元素
利用浏览器缓存：通过`Cache-control`和`Etag`等HTTP来控制
使用CDN加快资源加载速度，或者合并和压缩资源。
**TCP与UDP的区别，在前端的应用场景分别是什么**

|        |                        |                            |
| ------ | ---------------------- | -------------------------- |
|        | UDP                    | TCP                        |
| 是否连接   | 无连接                    | 面向连接                       |
| 是否可靠   | 不可靠传输，不使用流量控制和拥塞控制     | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信  | 只能是一对一通信                   |
| 传输方式   | 面向报文                   | 面向字节流                      |
| 首部开销   | 首部开销小，仅8字节             | 首部最小20字节，最大60字节            |
| 适用场景   | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输        |

**进程和线程区别**
进程是分配资源的最小单位，具有独立的内存空间和资源，需要高度隔离和安全的场景
线程是调度的最小单位，多个线程之间共用同一进程的资源，往往使用共享内存来实现通过。
可以将进程和线程比作：厂和厂房，厂房共用同一个厂的资源，同时每个厂房都可以独立运作去干自己的事情。
**前端如何使用多线程概念**
js是单线程的，但是浏览器是多线程的。
前端中使用多线程可以借助浏览器。
1. webWorker：Web Workers 在自己的全局上下文中运行，无法直接访问 DOM。主线程和 Worker 线程之间通过 `postMessage` 和 `onmessage` 进行通信。可以用于复杂计算的函数。比如大文件分片上传解析hash值。
```js
// main.js
const worker = new Worker('worker.js');

worker.postMessage('Hello, Worker!');

worker.onmessage = function(e) {
  console.log('从 Worker 收到的消息：', e.data);
};

```
2. Service Worker: 是一种特殊的 Web Worker，运行在后台，能够实现离线缓存、后台同步、推送通知等功能。
	- **缓存管理**：Service Workers 可以拦截网络请求并提供缓存资源，使得网站具有更快的加载速度和离线能力。
	- **后台同步**：允许在网络恢复时进行后台数据同步，提高用户体验。
	- **推送通知**：即使在浏览器关闭的情况下，也可以通过 Service Workers 向用户推送通知。
```js
// service-worker.js
self.addEventListener('install', (event) => {
  console.log('Service Worker 安装中。');
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});

```

3. WebAssembly:可以在浏览器中运行接近原生速度的代码。
特点：
-  **高性能**：WebAssembly 能以接近原生的速度执行计算密集型任务。
- **互操作性**：可以与 JavaScript 结合使用，允许开发者在前端利用其他语言的代码库。

4. Atomics和SharedArrayBuffer
**SharedArrayBuffer** 和 **Atomics** 提供了一种在线程之间共享内存的方法，使得真正的并行计算成为可能。
- **共享内存**：允许在主线程和 Worker 之间共享内存，适合高性能计算任务。
- **原子操作**：使用 Atomics 可以保证对共享数据的安全操作，避免竞态条件。
```js
// main.js
const buffer = new SharedArrayBuffer(1024);
const array = new Int32Array(buffer);
const worker = new Worker('worker.js');

worker.postMessage(buffer);

// worker.js
onmessage = function(e) {
  const array = new Int32Array(e.data);
  Atomics.add(array, 0, 10);
  console.log(Atomics.load(array, 0)); // 应该打印 10
};

```


**死锁是什么，为什么会引起死锁，其解决方案是什么**
死锁是指两个或多个进程（或线程）因竞争资源而相互等待，且都无法继续执行的一种状态。在这种情况下，这些进程（或线程）都在等待其他进程释放资源，而其他进程也在等待它们释放资源，导致所有进程都无法继续运行。

死锁发生的条件
1. 互斥条件：资源只能唯一占领，同一时间只能有一个进程使用某个资源
2. 持有并等待条件：进程至少拥有一个资源，同时又在等待获取一个或者多个其他进程占有的资源
3. 不可剥夺条件：资源不可被剥夺
4. 循环等待条件：存在一个进程链，使得每个进程都在等待下一个进程所占有的资源。

死锁的解决方案：
预防、避免、检测和恢复

预防：破坏死锁发生的四个条件即可

避免：银行家算法。实际上在计算机中资源的请求都是不可预知的，所有这个几乎不可能用在计算机上。


死锁的检测和恢复：
检测：定期或在资源请求被拒绝时，系统可以运行死锁检测算法，通过检测进程间的资源依赖图或使用检测矩阵等方法，判断是否存在死锁。
恢复：一旦检测到死锁，可以通过以下方式恢复系统：
- **终止进程**：选择一个或多个进程终止，以打破死锁循环。这种方式虽然简单，但可能会导致数据丢失或需要重启任务。（大多数会计算代价最小的进程）
- **资源抢占**：强制从死锁进程中剥夺某些资源，并将这些资源分配给其他进程，以打破循环。


HTTP/HTTPs的基本工作原理及其区别？如何确保前端应用的安全性？

### 性能相关
**白屏问题如何解决？**
1. 减少页面资源的加载时间：
	1. 优化资源大小
		1. 代码分块
	2. 延迟加载非关键资源
		1. defer/async延迟js文件
	3. 懒加载图片视频
2. 提高首屏渲染时长
	1. 服务端渲染：解决白屏问题和SPA的SEO问题
	2. 骨架屏，css骨架屏
3. 优化DNS解析和网络请求
	1. DNS预解析：`<link rel="dns-prefetch" src="www.baidu"></link>`
		1. 这里是预先解析出来域名对应的IP地址
	2. CDN，使用全球内容分发网络对资源的加载优化
		1. 这里CDN加速是因为，CDN会根据IP所在地，调用最近的服务器上（也不一定是最近，因为存在负载均衡，如何这个服务器被请求太多了，那么换其他比较空闲的服务器），其次还有缓存存在。

**性能优化的指标有哪些，如何拿到**
1. 首次内容绘制 (First Contentful Paint，FCP)
2. 最大内容绘制 (Largest Contentful Paint，LCP)
3. 首次输入延迟 (First Input Delay ，FID)
4. 交互到绘制延迟（Interaction to Next Paint，INP）
5. 累积布局偏移 (Cumulative Layout Shift，CLS)
6. 第一字节时间 (Time to First Byte，TTFB)
通过window上面的performance对象拿到对应的属性

## 你在快手做过哪些项目
**为什么从快手离职**
1. 当时打算就是干三个月左右，为后面大三的实习做一些铺垫
2. 正值要回学校参加补考+自己打算休息一段时间，感觉自己长期不回不太好
3. 自己还是想去字节这样的大公司去看看，虽然快手也是大厂了，但是每个公司是有不同的特点的，而且字节也是我开始就想去的公司。
**你在快手做了什么**？
我在快手主要是做客服平台web端的功能迭代开发。
参与的需求有，打标优化，chat工作台状态条优化等
**你实习遇到的最大挑战是什么？**
遇到的困难并不是太大，稍微在前期没有头绪的是打标优化的项目，参与技术评审时，对于这个平台不是很熟悉，当时遇到是需要，对树形结构保持展开。因为每一次更新工单，都会导致工单列表的刷新，工单列表刷新之后对于树形而言是默认都不展开或者都展开的。
然后我这边开始认为是需要通过点击获取点击的某一个工单项，并且记录下来，如果进行打标操作之后，工单刷新，然后默认就全部收起，我开始认为是需要获取到对应的DOM元素然后让他scrollIntoview来实现重新出现到列表中。
但是实际上可以通过修改节点的expanded属性来控制展开。这个操作是放在nextTick里面的，因为这个树形结构和一个数组相关联，数组变动，树形结构默认会变为收起，这里当DOM更新之后再去操作dom结构，因为不这样，反而同步去操作DOM的话，大概率这个DOM操作的行为会被后续数据更新导致的DOM更新所覆盖。

### 打标优化
#### 业务背景
客服工作台——工单工作台涉及到大量工单，需要客服处理，但是之前的现状是，有一个小旗帜标识不同的工单，这个小旗帜无法自定义，且只有三种颜色，产品根据客服的反馈做了调研，后续得到需要`自定义+快速打标`的需求迭代。
#### 业务方案
将以前一维的数组变为一二维交替（不进行旗帜分组时是一维，进行旗帜分组时是二维，这个二维是通过树形解决的。）
在二维列表中对每一个工单列表项支持`contextmenu`事件支持右键快速唤起打标列表。
同时在工单列表支持一个对当前客服旗帜的自定义更改。
>可拓展：鼠标滚轮事件是什么`@wheel`，鼠标移动事件`@mousemove`

#### 业务难点：
在工单列表右侧存在一个工单详情，里面可以对工单进行一些操作，比如备注，更改工单状态、流转工单等等操作。
这里更改工单状态之后，会有一个消息推送过来，这里使用的link（websocket的一个应用），通过link接收到消息的推送，从而直接改变工单列表中某一个工单的状态。
这里做了websocket来获取更新，因为主从延迟，在发送请求之后再立刻去请求得到的数据为脏数据，因此采用乐观更新

>**提问**：为什么不直接通过获取工单列表的接口再次获取。
>因为这里获取的工单消息并没有及时更新，因为这个工单数据和多个平台绑定，服务端更新时间长达两三秒，导致一旦通过推送发过来的消息立即去请求，得到的数据并不是一致的。（这个是对接的后端说的有时延的问题）。
>
>**继续提问**：那么如何去保障数据一致性。
>对于前端来说，可以通过确认唯一的link，避免多个link向服务端推送消息导致数据错乱（真正业务中没有向服务端推送的东西，我接触到的）。将全局唯一的link挂载到window上。
>后端的话可以使用。
> - 消息队列比如Kafka之类的将存储的信息发送到消息队列中然后另一个订阅的系统对这个做处理
> - 可以采用redis来进行缓存。
> - 还有采用锁防止同一条数据被同一时间篡改。
>   **提问**：websocket断开如何处理
>   断开之后，是存在重连机制的。且每次重连都会在控制台输出，以便开发人员监听，且做了相对应的埋点处理。
至于为什么使用websocket而不是用轮询，是因为我们已经有一套websocket的方案了，已经和后端达成共识，不用再去封装。






这里我有做得不好的点，因为我是有一个调用获取分组的接口，然后监听的是工单变化，就调用这个接口。
产生的影响：频繁调用接口（这里做了防抖处理）。在灰度使用中出现过，工单的标签更新了，但是工单列表中的没有更新，就是因为上述提到的问题（工单列表第一时间更新，但是数据库中的数据并不是同步更新，导致获取的数据和目的数据不一致）

>**提问**:工单是可以处于多个状态的。那么有没有什么状态回滚的方案，比如一个工单需要ABCDE客服处理（实际上不合理，因为客服人力也是一个很大的资源消耗），B手滑不小心通过审核，需要从C中重新拿回工单应该如何做。
>**答**：补救措施：这里可以定制化开发一个按钮，对于状态有误的工单，可以通过按钮+弹窗（申请理由）拿回工单，同时在弹窗完成之后，发起的请求中使用锁，对于请求的工单进行锁定，防止在这个过程中其他人操作，等待拿回之后，再将锁解除）
>预防措施：在进入下一个流程时，出现弹窗，确认是否进入下一个流程，以避免工单的意外流出。


### Chat工作台状态条优化
#### 业务背景
用户与商家沟通出现矛盾时，需要客服处理，但是每个客服都有自己的技能组，每个技能组都有闭线时间，如果到达闭线时间的话，那么客服就相当于下班了，但是客服无法感知当前技能组是否有排队的人数（需要客服介入的用户），造成用户体验感丢失。
#### 业务方案
这里就做了一个排队人数的展示+达到闭线时长且有人等待的情况下出现弹窗的小需求

#### 业务难点
这里的难点主要是一个浏览器相关的问题。
对于chat工作台的状态条部分，是有关当前客服的状态的：工作、小休、其他，这个状态通过接口获取。这里也可以通过点击各个状态的面板进行切换状态，问题就出现在切换状态这里。
当客服人员，新开其他窗口，然后隔几分钟~十几分再次切回页面，状态丢失，这里涉及到状态的改变，然后就使用watch监听状态变化，如果是新值是undefined就再次调用接口。

#### 业务收益
提高需客服处理的用户体验感。
但是有些点没有考虑到，可能客服即将下班，但是处理这个用户如果时间过长，客服体验感差。
有另外的方案考虑：客服是存在两个轮次的，如果即将下班就不会进线即将闭线的客服，但是这样可能导致用户等待时间过长，这里需要一个好的调度算法，或者是，当接近下班时间在处理这个的客服可以转接给其他已经上班的客服技能组，然后获取对应的上下文，以解决用户和客服的问题。（这里有转接功能，可以讲客服手持的人员转接到其他人上，但是这个是不能获取上下文的，那么这里有一点缺陷，同时这个接入了ai，当ai不能解决就会有转人工的操作）
### 代客新增/修改poi
#### 预计收益
![](https://files.catbox.moe/uru74x.png)
大概节约 0.47人/日  以6月 13单/日的流转处理量折算。
#### 需求背景
商家可以通过电脑端或手机端，使用【店铺装修】、【商家认领门店环节-自助新增/修改POI】的能力。但是实际服务测的问题监控场景中发现，由于功能上线导致poi中台不在承接人工反馈需求，且客服不支持代客修改，即不能通过客服平台为商家的反馈去做对应的修改，需要联通两个平台，导致用户进线后体验较差
 
#### 技术方案
在工单工作台实现一个特殊回执，包括对poi信息的新增/修改 +地图组件的显示和反显，这个地图的需求是要和poi中台那边对齐，其次就是为了让输入地址之后能够在地图上显示的可视化以更多维的角度对地址的确认。
高德api中的`getLocation和getAddress`分别获取经纬度和地址
我个人的看法：对这个需求感到有点不合理，这个poi中台应该兼顾接受反馈的渠道，但是所有的人工反馈都走的客服通道，导致客服平台需要做出兼容，以便客服人员对poi信息的处理。
## 其他

一、轮询（Polling）
1. 短轮询（Short Polling）
- ​**实现方式**：客户端定时（如每秒）向服务器发送请求，无论是否有数据更新。
- ​**优点**：
    - ​**兼容性高**：所有浏览器和服务器均支持（基于 HTTP）。
    - ​**实现简单**：无需特殊协议或库。
- ​**缺点**：
    - ​**高延迟**：数据更新取决于轮询间隔，实时性差。
    - ​**资源浪费**：频繁请求导致带宽和服务器资源浪费。
    - ​**并发压力**：高频率请求可能引发服务器过载。

​2. 长轮询（Long Polling）

- ​**实现方式**：客户端发送请求后，服务器保持连接直到有新数据或超时，再重新发起请求。
- ​**优点**：
    - ​**实时性较好**：减少无意义请求，数据到达后立即返回。
    - ​**节省带宽**：相比短轮询，减少无效请求次数。
- ​**缺点**：
    - ​**服务器开销**：大量挂起连接占用服务器资源。
    - ​**实现复杂**：需处理连接超时和重连逻辑。
    - ​**潜在延迟**：超时后仍需重新建立连接。

---

 ​二、WebSocket**

- ​**实现方式**：基于 TCP 的全双工通信协议，建立持久连接后，客户端和服务器可随时双向传输数据。
- ​**优点**：
    - ​**实时性强**：数据即时推送，毫秒级延迟。
    - ​**高效通信**：无 HTTP 头开销，节省带宽。
    - ​**低服务器压力**：一个连接支持持续通信，减少并发请求。
- ​**缺点**：
    - ​**兼容性限制**：需浏览器支持 WebSocket（IE10+），部分防火墙可能拦截 WebSocket 连接。
    - ​**实现复杂**：需处理连接状态维护、心跳检测、重连机制等。
    - ​**协议升级**：需服务器支持 WebSocket 协议（如 Node.js 的 `ws` 库）。

---

 ​**三、对比总结**

|​**对比维度**​|​**短轮询**​|​**长轮询**​|​**WebSocket**​|
|---|---|---|---|
|​**实时性**​|低（依赖轮询间隔）|中（数据到达后立即响应）|高（即时推送）|
|​**带宽消耗**​|高（频繁请求）|中（减少无效请求）|低（无 HTTP 头，持久连接）|
|​**服务器压力**​|高（高并发请求）|中（挂起连接占用资源）|低（单连接复用）|
|​**兼容性**​|所有浏览器|所有浏览器|IE10+ 及现代浏览器|
|​**实现复杂度**​|简单|中等|复杂|
|​**适用场景**​|低频更新（如天气预报）|中等实时性（如聊天室）|高频双向通信（如实时游戏）|

---

 ​**四、选型建议**

1. ​**优先 WebSocket**：
    
    - 需要高频双向通信（如在线协作编辑、股票行情）。
    - 要求低延迟和高效资源利用（如视频弹幕、实时监控）。
    - 示例代码：
        
        javascript
        
        ```javascript
        const socket = new WebSocket('ws://api.example.com');
        socket.onmessage = (event) => {
          console.log('Received:', event.data);
        };
        ```
        
2. ​**考虑长轮询**：
    
    - 需兼容旧版浏览器（如 IE9）。
    - 实时性要求一般且更新频率较低（如邮件通知）。
    - 示例代码：
        
        javascript
        
        ```javascript
        function longPoll() {
          fetch('/api/data').then(response => {
            processData(response);
            longPoll(); // 递归调用维持长轮询
          });
        }
        ```
        
3. ​**避免短轮询**：
    
    - 仅在极低频更新或快速验证原型时使用。

---

**五、优化策略**

- ​**WebSocket 增强**：
    - ​**心跳机制**：定时发送 ping/pong 维持连接。
    - ​**重连逻辑**：监听 `onclose` 事件并自动重连。
    - ​**降级方案**：不支持 WebSocket 时切换为长轮询。
- ​**轮询优化**：
    - ​**动态间隔**：根据数据更新频率调整轮询间隔。
    - ​**增量更新**：仅请求变化部分数据（如使用 `Last-Modified` 头）。

**问题**：你提到你们部门做的数据埋点、监控这些可以聊聊吗？
答：我本身需求上是没有做埋点、监控相关的，我们组内有专门的人去负责埋点、以及监控页面的搭建，这个监控主要是监控异常，包括卡顿、报错、白屏等，但是异常卡死应该是没有做埋点收集的，因为当时是正在讨论这个事情的可行性，包括c端的埋点。
这里对于报错主要有js报错和异步报错。js报错的话可以在`window.onerror`来实现对报错的监听，对于异步报错，可以通过全局挂载`unhandledrejection`


面试问题：
## 菜逼遗留问题解决
1. history和hash的区别
2. Es5 6 7 8 9 10 11 12 13 14 15 16 17
3. 唤端
4. webpack+vite
5. 浏览器渲染原理
6. 浏览器缓存
7. 性能指标
8. v2-v3 v3响应式 
9. css 优先级
10. undefined null
11. == ===
12. Promise 
    1. 取消一个Promise，AbortControl
13. 事件循环
14. ipc 通信，进程间通信
15. websocket
16. SSR ISR CSR SSG
17. SSE 
18. chatGPT 流式传输
19. 小程序启动优化策略
20. YJS OT CRDT
21. token 无感刷新
22. Get Post 区别
23. JS 基本数据类型
24. 预检请求
25. 跨域才会有预检请求吗？
26. 什么是跨域？
27. 组件间通信问题
28. 为什么webpack万物皆可模块
29. url-loader干什么的？
30. vite为什么快？
31. css主题切换方案
32. 闭包是什么？优缺点？
33. https的作用
34. https是非对称加密，如何交换密钥呢？
35. SSL TLS 握手分别几次？如何做的？
---
## 点对点硬撼
1. JS 基本类型
>[!info]
>1.七种基本数据类型 
>- **布尔值Boolean**: true & false
>- **null**, 一个表明 null 值的关键字。JS是大小敏感的，因此 null Null NULL 完全不同
>- **undefined**
>- **数字 Number**
>- **字符串 String**
>- **代表 Symbol** 实例是唯一不可变的类型
>- **任意精度的整数 BigInt**
>2. 引用类型 **Object**
>- Object
>- Array
>- Function
>- Set
>- Map
>- ...
1. == ===
>[!info]
>[[类型的隐式转换]]
1. 事件冒泡和捕获，JS事件流
>[!info]
>xxx
1. CSS 水平垂直居中的方式
2. https比http多了什么？https的大致原理
3. https的加密过程，对称加密和非对称加密算法的流程是什么？
4. webpack/vite的最主要区别
5. vite为什么比Webpack快，为什么？冷启动原理是什么？
6. vite在生产环境下是用什么打包？
7. 开发到提交用git的一般步骤到常见命令
8. 了解跨域吗？什么是跨域？如何解决?
9. **数组扁平化，合法括号**
10. **异步任务看代码说输出，JS作用域问题，两数之和，高精度加法**
11. http缓存策略
12. max-age是什么？值是什么？
13. cache-control字段了解吗？
14. expire听说过吗？
15. max-age和expire的联系
16. https安全在什么地方
17. 对称加密和非对称加密分别加密的是什么内容
18. 最近在学什么前端技术？
19. React和Vue之间在响应式上实现的差异是什么？
20. React和Vue的使用上，学习阶段上最明显的差异
21. 函数式编程
22. React进行虚拟元素对比，大概的流程是什么？
23. 针对什么资源进行强缓存？
24. 浏览器事件循环机制
25. 如何判断一个任务是宏任务还是微任务
26. **最长回文子串**
27. CSS中的flex布局，一般会用到哪些应用场景？会用到哪些业务属性？
28. opaticy: 0; visibility: hidden; display: none有什么区别？如果要响应鼠标的事件的话，这三个属性设置了都可以触发吗？
29. `i = 1; let i = 2;`在哪行报错？
30. **异步输出**
31. 了解TS吗？
32. webpack plugin loader
33. 怎么优化首屏加载速度？
34. **三道大数相加并发限制的异步解调器，同时只能运行两个任务，怎么写？实现一个 Event 事件观察者的类**
35. 发布订阅模式
36. 不同设备的兼容性是怎么做的？
37. 媒体查询？
38. cookie session 区别
39. 为什么需要有sessionID
40. 没有sesssionId会出现什么？
41. 说一下localStorage, sessionStorage
42. 怎么设置一套用户的权限管理系统？根据用户权限判断用户是否能登录，以及登录后能看到的路由和同一个界面不同用户可能会看到不同的内容？在做不同用户同一页面展示不同内容时，怎么封装出来一个通用的设计模式？
43. **LRU缓存**
44. **loadsh.get()**
45. **深拷贝**
46. **岛屿数量，最大岛屿面积**
47. Formily原理
48. 常用的hooks
49. setTimeout和setInterval倒计时是精确的吗
50. 有什么更好的倒计时的实现方式？
51. 浏览器进程 线程
52. 结合线程讲事件循环
53. 网络进程和异步http线程关系
54. **函数柯里化**
55. **括号生成**
56. [字节前端商业化一二三面面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/411136220913299456?sourceSSR=search)


