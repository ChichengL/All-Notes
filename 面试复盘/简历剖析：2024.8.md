**Star法则：情景（Situation），任务（Task），行动（Action），结果（Result）** 

### HTML/CSS
**CSS的盒子模型工作原理且如何在不同的浏览器中确保一致性?**
盒子模型，每个HTML元素都被当作一个矩形的盒子，由内到外
内容区域、内边距、边框、外边距。
标准盒子模型：默认情况下，`width`和`height`只包含内容区域的宽高，不包括内边距和边框。实际占用空间的计算公式是：
```css
总宽度 = width + padding-left + padding-right + border-left + border-right 总高度 = height + padding-top + padding-bottom + border-top + border-**bottom**
```
怪异盒子模型（ie盒子模型）：在这种模型中，`width`和`height`包括了内容区域、内边距和边框的总和。这意味着内边距和边框会从设置的`width`和`height`中扣除。
通过设置`box-sizing: border-box;`可以切换到这种模型。
一致性可以通过`box-sizing:border-box`来让盒子模型在所有浏览器中表现一致。

**谈谈你对css预处理器的理解，如何提高开发效率**
CSS预处理器的特点：变量（CSS也有）、嵌套（CSS新版也有）、继承与混合、函数运算、模块化


### ES6有哪些新特性：
let/const、箭头函数和Class类、模版字符串、解构赋值和展开运算符、默认参数、、for ... in/of 循环、map/set数据结构、Promise、Symbol
延展let/const/var有什么区别：var 是es6之前声明变量的操作符，let/const是es6及之后的。
他们的区别：
**var**
var声明的变量存在变量提升，这个变量提升在function声明函数时也会存在。
var声明的变量挂载到window（全局对象）上的，且不会被局部作用域所框束。

所以会存在一些问题比如：
```js
for(var i = 0; i < 10; i ++){
    setTimeout(()=>{console.log(i)});
}
```
这个打印10个10；
要想解决也很简单：1. 换为let，2.使用IFFE将变量保留

原因：每次循环都是一个局部作用域，因此每次的i是不同的，只在自己的作用域有效，所以打印出的值是当前作用域的值。（对于换为let）
对于换为IFFE，是因为相当于是一个闭包，保留了当前的值

**let/const**
let声明的变量可变，const声明的变量不可变。这里的可变与不可变并非绝对，对于const声明的基本类型是不可变的，而对于const声明的引用类型是可以变化的。
且这两个都会有TDZ（暂时性死区的存在），如果在声明之前使用就会报错。

**箭头函数和Class**
这两者的出现是为了解决函数的二义性，即可做函数也可做类。
箭头函数没有自己的this只能使用上一层的this
```js
const a = ()=>{
    console.log('a',this);
}
function b(){
    console.log('b',this);
}
a();
b();
```

在浏览器环境，两个打印的都是`window`,但是在node环境a打印的空对象，b打印的window。
因为a调用的时候没有自己的this，只会从外部上下文环境中获取，在nodejs中顶层代码的this指向空对象。对于普通函数的 `this` 取决于函数的调用方式。在顶层代码中直接调用 `b()`，`this` 指向的是全局对象。

class的作用：封装、继承、多态（面相对象的特性）

**模版字符串**
可以支持换行+字符占位
其大概实现：
```js
const year = '2024'
const month = '08'
const day = '19'
function render(str){
    return str.replace(/\$\{(\w+)\}/g,(match,key)=>{
        return eval(key);
    })
}
console.log(render('${year}-${month}-${day}'));
```

**解构赋值和展开运算符**

解构：数组解构，对象解构
```js
const arr = [1,2];
const [a,b] = arr;

const obj = {name:'1',age:18};
let objClone = { ...obj };
```
这里展开运算符可以做浅拷贝
浅拷贝的其他实现方案：Object.assign，手动实现浅拷贝，数组的slice，Array.from，concat方法也可以实现浅拷贝
拓展：深拷贝和浅拷贝区别
浅拷贝只拷贝数据，如果有引用类型，会导致共用一个引用类型，引发数据混乱的问题。
深拷贝实现
```js
const deepCopyOptimization = (obj) => {
    const cache = new WeakMap();
    const copy = (obj) => {
        if (typeof obj !== 'object' || obj === null) {
            return obj;
        }
        if (cache.has(obj)) {
            return cache.get(obj);
        }
        const newObj = Array.isArray(obj)? [] : {};
        cache.set(obj, newObj);
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                newObj[key] = copy(obj[key]);
            }
        }
        return newObj;
    }
    return copy(obj);
}
```
这个没有考虑map，set，symbol等数据结构。
获取Symbol需要使用`Object.getOwnPropertySymbols(obj)`

for...in/ of
for...in是用来遍历键的，针对于对象。
for...of是用来获取值的，只有实现了`Symbol.iterator`的才可以使用for...of来获取值
对象是不能使用for...of来获取值的，但是可以手动做到
```js
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        for(let key in this){
            yield key;
        }
    }
}
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        // for(let key in this){
        //     yield key;
        // }
        const keys = Object.keys(this); // 获取对象自身的所有键
        let index = 0;
        return {
            next: () => {
                if (index < keys.length) {
                    return { value: this[keys[index++]], done: false };
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
    }
}
for(let key in obj3){
    console.log(key)
}
for(let key of obj3){
    console.log(key)
}

```
这样for...in/of都可以遍历对象了。


**Promise**
一文弄懂[Promise](http://www.chichengl.xyz/archives/yi-wen-nong-dong-promiseji-qi-shou-xie)
async/await 可以看作是promise+generator的语法糖。

### Vue相关
Vue2和Vue3的区别在哪里：
- api——组合式与选项式：更加细腻的api，如shallowRef
- 响应式的重构
   - vue2：defineProperty
   - vue3：proxy
- 内置组件的变化
   - **新增了：Fragment、Teleport（vue3.2及之前的版本是有内存泄露的风险）、Suspense**
- **生命周期的变化**
- diff算法的优化
- **类型安全**
   - vue3支持了ts
- **模块化**
   - vue2默认是webpack
   - vue3默认是vite
- **vue3新增了tree-shaking**

响应式本质是：数据与函数的联动，数据变化催发函数执行的过程。
响应式的实现：defineProperty，Proxy，观察者模式+发布订阅

**vue3的组合式api相较于vue2的选项式api有什么优势**
更好的代码组织和逻辑复用，可以将相关的函数集中放置。
更好的类型支持。
更好的treeShaking支持。

**VueRouter有了解吗？VueRouter有两种模式，hash模式和history模式**
router和route的区别：
router：是操作路由的对象，可以通过router进行函数式对路由进行函数式操作
route是路由元信息，存储着当前路由下的query等信息。
hash模式：Hash模式使用URL的`#`符号（也称为“锚点”）来模拟不同的路径。当哈希值改变时，浏览器的`hashchange`事件会被触发，VueRouter通过监听这个事件来切换视图。
优点：兼容性过更强，不需要服务端的配置，因为hash部分不包含在http请求，前端就可以处理
缺点：url不美观，seo支持不友好。

history模式：History模式利用HTML5的`history.pushState`和`history.replaceState` API，在VueRouter的History模式下，URL是“真实的路径”，例如`http://example.com/home`，而不是通过哈希来模拟路径。
优点：SEO友好，更强的历史管理，push等操作可以被历史记录导航所使用（浏览器的前进后退）
缺点：需要服务端搭配，旧版浏览器不兼容

**了解过Vue-cli，还了解过webpack和vite？**
vue-cli的是什么，vue-cli是一个基于webpack的脚手架，便于快速搭建vue等项目。

webpack和vite都是打包构建工具，webpack出现时间更早，生态更加成熟，但是是基于js所编写，其天然对js有打包能力，其他对图片的打包需要通过相对应的loader来实现。
vite出现时间稍晚，但是其打包速度以及热更新速度很快，其生态也愈发完善。

**vite为什么比webpack更快，有什么优势?**
Vite基于rollup+esmodule，在开发阶段的打包构建，是“no bundle的”没有打包这个概念，让浏览器全权决定打包，其次他的热更新是定点更新，一个文件更新，只有其他依赖了这个文件的文件才会一同更新，而非类似于webpack全量的再去递归寻找依赖关系进而更新


**Vue的VNode了解吗，什么是虚拟DOM，虚拟DOM有什么好处？**
虚拟DOM就是以一个对象来描述DOM节点的信息，VNode其实就是vue中的虚拟DOM，通过操作虚拟DOM替代直接操作浏览器中的DOM。

虚拟DOM的好处：
1. 多次操作DOM的情况下，会引发多次回流、重绘，但是多次操作虚拟DOM再一次操作真实的DOM是比较好的。
2. 跨平台，虚拟DOM是一层抽象结构，可以实现跨平台的渲染。
3. 更高效的更新，通过diff算法，来比较前后两次虚拟DOM的差异，并值更新那些实际发生变化的部分，避免了全量重回，提高了性能。

**什么是Vue中的“依赖收集”？它是如何工作的？**
Vue中的依赖收集是vue实现响应式的核心部分，通过它，Vue能够自动追踪哪些组件或函数依赖于某些响应式数据，从而在数据变化时自动更新相关视图。
依赖收集的工作机制主要依赖于`Object.defineProperty`（Vue2）或`Proxy`（Vue3）。当我们在组件中访问某个响应式数据时，Vue会拦截这个数据的读取操作（通过`getter`），将当前的组件或计算属性函数作为“订阅者”记录下来，添加到该数据的依赖列表中。这些“订阅者”通常由Vue内部的“Dep”类或“ReactiveEffect”类管理。

当数据发生变化时，Vue会通过`setter`触发通知，遍历依赖列表中的所有“订阅者”，并执行它们的更新操作。这样，只有与变化数据相关的部分组件或计算属性会被重新计算或重新渲染，提升了应用的性能和响应速度。



### 计算机基础+计网
**从输入url到展示页面的过程**

1. 先判断输入内容是否为有效的网址，如果不是按照浏览器设定的搜索引擎进行搜索，如果是那么就当作地址去查找IP。
2. 通过域名