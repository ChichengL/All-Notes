**Star法则：情景（Situation），任务（Task），行动（Action），结果（Result）** 

### HTML/CSS
**CSS的盒子模型工作原理且如何在不同的浏览器中确保一致性?**
盒子模型，每个HTML元素都被当作一个矩形的盒子，由内到外
内容区域、内边距、边框、外边距。
标准盒子模型：默认情况下，`width`和`height`只包含内容区域的宽高，不包括内边距和边框。实际占用空间的计算公式是：
```css
总宽度 = width + padding-left + padding-right + border-left + border-right 总高度 = height + padding-top + padding-bottom + border-top + border-**bottom**
```
怪异盒子模型（ie盒子模型）：在这种模型中，`width`和`height`包括了内容区域、内边距和边框的总和。这意味着内边距和边框会从设置的`width`和`height`中扣除。
通过设置`box-sizing: border-box;`可以切换到这种模型。
一致性可以通过`box-sizing:border-box`来让盒子模型在所有浏览器中表现一致。

**谈谈你对css预处理器的理解，如何提高开发效率**
CSS预处理器的特点：变量（CSS也有）、嵌套（CSS新版也有）、继承与混合、函数运算、模块化


### ES6有哪些新特性：
let/const、箭头函数和Class类、模版字符串、解构赋值和展开运算符、默认参数、、for ... in/of 循环、map/set数据结构、Promise、Symbol
延展let/const/var有什么区别：var 是es6之前声明变量的操作符，let/const是es6及之后的。
他们的区别：
**var**
var声明的变量存在变量提升，这个变量提升在function声明函数时也会存在。
var声明的变量挂载到window（全局对象）上的，且不会被局部作用域所框束。

所以会存在一些问题比如：
```js
for(var i = 0; i < 10; i ++){
    setTimeout(()=>{console.log(i)});
}
```
这个打印10个10；
要想解决也很简单：1. 换为let，2.使用IFFE将变量保留

原因：每次循环都是一个局部作用域，因此每次的i是不同的，只在自己的作用域有效，所以打印出的值是当前作用域的值。（对于换为let）
对于换为IFFE，是因为相当于是一个闭包，保留了当前的值

**let/const**
let声明的变量可变，const声明的变量不可变。这里的可变与不可变并非绝对，对于const声明的基本类型是不可变的，而对于const声明的引用类型是可以变化的。
且这两个都会有TDZ（暂时性死区的存在），如果在声明之前使用就会报错。

**箭头函数和Class**
这两者的出现是为了解决函数的二义性，即可做函数也可做类。
箭头函数没有自己的this只能使用上一层的this
```js
const a = ()=>{
    console.log('a',this);
}
function b(){
    console.log('b',this);
}
a();
b();
```

在浏览器环境，两个打印的都是`window`,但是在node环境a打印的空对象，b打印的window。
因为a调用的时候没有自己的this，只会从外部上下文环境中获取，在nodejs中顶层代码的this指向空对象。对于普通函数的 `this` 取决于函数的调用方式。在顶层代码中直接调用 `b()`，`this` 指向的是全局对象。

class的作用：封装、继承、多态（面相对象的特性）

**模版字符串**
可以支持换行+字符占位
其大概实现：
```js
const year = '2024'
const month = '08'
const day = '19'
function render(str){
    return str.replace(/\$\{(\w+)\}/g,(match,key)=>{
        return eval(key);
    })
}
console.log(render('${year}-${month}-${day}'));
```

**解构赋值和展开运算符**

解构：数组解构，对象解构
```js
const arr = [1,2];
const [a,b] = arr;

const obj = {name:'1',age:18};
let objClone = { ...obj };
```
这里展开运算符可以做浅拷贝
浅拷贝的其他实现方案：Object.assign，手动实现浅拷贝，数组的slice，Array.from，concat方法也可以实现浅拷贝
拓展：深拷贝和浅拷贝区别
浅拷贝只拷贝数据，如果有引用类型，会导致共用一个引用类型，引发数据混乱的问题。
深拷贝实现
```js
const deepCopyOptimization = (obj) => {
    const cache = new WeakMap();
    const copy = (obj) => {
        if (typeof obj !== 'object' || obj === null) {
            return obj;
        }
        if (cache.has(obj)) {
            return cache.get(obj);
        }
        const newObj = Array.isArray(obj)? [] : {};
        cache.set(obj, newObj);
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                newObj[key] = copy(obj[key]);
            }
        }
        return newObj;
    }
    return copy(obj);
}
```
这个没有考虑map，set，symbol等数据结构。
获取Symbol需要使用`Object.getOwnPropertySymbols(obj)`

for...in/ of
for...in是用来遍历键的，针对于对象。
for...of是用来获取值的，只有实现了`Symbol.iterator`的才可以使用for...of来获取值
对象是不能使用for...of来获取值的，但是可以手动做到
```js
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        for(let key in this){
            yield key;
        }
    }
}
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        // for(let key in this){
        //     yield key;
        // }
        const keys = Object.keys(this); // 获取对象自身的所有键
        let index = 0;
        return {
            next: () => {
                if (index < keys.length) {
                    return { value: this[keys[index++]], done: false };
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
    }
}
for(let key in obj3){
    console.log(key)
}
for(let key of obj3){
    console.log(key)
}

```
这样for...in/of都可以遍历对象了。


**Promise**
一文弄懂[Promise](http://www.chichengl.xyz/archives/yi-wen-nong-dong-promiseji-qi-shou-xie)
async/await 可以看作是promise+generator的语法糖。

### Vue相关
Vue2和Vue3的区别在哪里：
- api——组合式与选项式：更加细腻的api，如shallowRef
- 响应式的重构
   - vue2：defineProperty
   - vue3：proxy
- 内置组件的变化
   - **新增了：Fragment、Teleport（vue3.2及之前的版本是有内存泄露的风险）、Suspense**
- **生命周期的变化**
- diff算法的优化
- **类型安全**
   - vue3支持了ts
- **模块化**
   - vue2默认是webpack
   - vue3默认是vite
- **vue3新增了tree-shaking**

响应式本质是：数据与函数的联动，数据变化催发函数执行的过程。
响应式的实现：defineProperty，Proxy，观察者模式+发布订阅

**vue3的组合式api相较于vue2的选项式api有什么优势**
更好的代码组织和逻辑复用，可以将相关的函数集中放置。
更好的类型支持。
更好的treeShaking支持。

**VueRouter有了解吗？VueRouter有两种模式，hash模式和history模式**
router和route的区别：
router：是操作路由的对象，可以通过router进行函数式对路由进行函数式操作
route是路由元信息，存储着当前路由下的query等信息。
hash模式：Hash模式使用URL的`#`符号（也称为“锚点”）来模拟不同的路径。当哈希值改变时，浏览器的`hashchange`事件会被触发，VueRouter通过监听这个事件来切换视图。
优点：兼容性过更强，不需要服务端的配置，因为hash部分不包含在http请求，前端就可以处理
缺点：url不美观，seo支持不友好。

history模式：History模式利用HTML5的`history.pushState`和`history.replaceState` API，在VueRouter的History模式下，URL是“真实的路径”，例如`http://example.com/home`，而不是通过哈希来模拟路径。
优点：SEO友好，更强的历史管理，push等操作可以被历史记录导航所使用（浏览器的前进后退）
缺点：需要服务端搭配，旧版浏览器不兼容

**了解过Vue-cli，还了解过webpack和vite？**
vue-cli的是什么，vue-cli是一个基于webpack的脚手架，便于快速搭建vue等项目。

webpack和vite都是打包构建工具，webpack出现时间更早，生态更加成熟，但是是基于js所编写，其天然对js有打包能力，其他对图片的打包需要通过相对应的loader来实现。
vite出现时间稍晚，但是其打包速度以及热更新速度很快，其生态也愈发完善。

**vite为什么比webpack更快，有什么优势?**
Vite基于rollup+esmodule，在开发阶段的打包构建，是“no bundle的”没有打包这个概念，让浏览器全权决定打包，其次他的热更新是定点更新，一个文件更新，只有其他依赖了这个文件的文件才会一同更新，而非类似于webpack全量的再去递归寻找依赖关系进而更新。


**Vue的VNode了解吗，什么是虚拟DOM，虚拟DOM有什么好处？**
虚拟DOM就是以一个对象来描述DOM节点的信息，VNode其实就是vue中的虚拟DOM，通过操作虚拟DOM替代直接操作浏览器中的DOM。

虚拟DOM的好处：
1. 多次操作DOM的情况下，会引发多次回流、重绘，但是多次操作虚拟DOM再一次操作真实的DOM是比较好的。
2. 跨平台，虚拟DOM是一层抽象结构，可以实现跨平台的渲染。
3. 更高效的更新，通过diff算法，来比较前后两次虚拟DOM的差异，并值更新那些实际发生变化的部分，避免了全量重回，提高了性能。

**什么是Vue中的“依赖收集”？它是如何工作的？**
Vue中的依赖收集是vue实现响应式的核心部分，通过它，Vue能够自动追踪哪些组件或函数依赖于某些响应式数据，从而在数据变化时自动更新相关视图。
依赖收集的工作机制主要依赖于`Object.defineProperty`（Vue2）或`Proxy`（Vue3）。当我们在组件中访问某个响应式数据时，Vue会拦截这个数据的读取操作（通过`getter`），将当前的组件或计算属性函数作为“订阅者”记录下来，添加到该数据的依赖列表中。这些“订阅者”通常由Vue内部的“Dep”类或“ReactiveEffect”类管理。

当数据发生变化时，Vue会通过`setter`触发通知，遍历依赖列表中的所有“订阅者”，并执行它们的更新操作。这样，只有与变化数据相关的部分组件或计算属性会被重新计算或重新渲染，提升了应用的性能和响应速度。



### 计算机基础+计网
**从输入url到展示页面的过程**

1. 先判断输入内容是否为有效的网址，如果不是按照浏览器设定的搜索引擎进行搜索，如果是那么就当作地址去查找IP。
2. 通过域名解析系统DNS，把域名转化为DNS，这里可以通过标签`<link rel="dns-prefetch" href="https://github.com"></link>`提前解析。这里拿到IP地址会先看本地的IP地址缓存，如果没有再通过DNS服务器去查找。查找有多种方式，有直接查找到根域名服务器的**递归查询**，也有每一次查询之后返回给客户端下一步需要查询哪个的DNS服务器的**迭代查询**。
3. 拿到IP地址之后就开始建立TCP连接：包括3次握手和四次挥手（详细可看<mark style="background: #FFB8EBA6;">部分计网</mark>）。这里TCP连接也可能是长链接。
4. 发送http请求，服务器处理请求并响应。
5. 浏览器接收到处理响应：
	1. 解析HTML建立DOM树
	2. 样式解析——解析CSS生成CSSOM
	3. 布局——计算布局，生成布局树
	4. 分层——渲染进程生成图层树
	5. 图层绘制
	6. 栅格化

这里相关的有重排和重绘；
重排：更新了元素的几何属性，如高度等，触发重新布局（从样式解析重走一遍），**重排需要更新完整的渲染流水线，所以开销也是最大的**
![](https://files.catbox.moe/yiyvd4.png)

重绘：更新的元素的背景，比如透明度变为0等情况，**重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**
![](https://files.catbox.moe/0c95p8.png)
更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做**合成**。比如使用transform，可以避开重排和重绘
![](https://files.catbox.moe/252cvp.png)


**说说你对渲染机制的理解，以及在优化页面渲染时你会考虑哪些因素**
尽可能减少重排重绘，比如减少DOM操作合理的使用动画之类的。
使用GPU加速，或者是在requestAnimationFrame来控制函数的执行
异步加载js，对于script标签使用
懒加载图片，减少不必要的DOM，避免过深的嵌套DOM元素
利用浏览器缓存：通过`Cache-control`和`Etag`等HTTP来控制
使用CDN加快资源加载速度，或者合并和压缩资源。
**TCP与UDP的区别，在前端的应用场景分别是什么**

|        |                        |                            |
| ------ | ---------------------- | -------------------------- |
|        | UDP                    | TCP                        |
| 是否连接   | 无连接                    | 面向连接                       |
| 是否可靠   | 不可靠传输，不使用流量控制和拥塞控制     | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信  | 只能是一对一通信                   |
| 传输方式   | 面向报文                   | 面向字节流                      |
| 首部开销   | 首部开销小，仅8字节             | 首部最小20字节，最大60字节            |
| 适用场景   | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输        |

**进程和线程区别**
进程是分配资源的最小单位，具有独立的内存空间和资源，需要高度隔离和安全的场景
线程是调度的最小单位，多个线程之间共用同一进程的资源，往往使用共享内存来实现通过。
可以将进程和线程比作：厂和厂房，厂房共用同一个厂的资源，同时每个厂房都可以独立运作去干自己的事情。
**前端如何使用多线程概念**
js是单线程的，但是浏览器是多线程的。
前端中使用多线程可以借助浏览器。
1. webWorker：Web Workers 在自己的全局上下文中运行，无法直接访问 DOM。主线程和 Worker 线程之间通过 `postMessage` 和 `onmessage` 进行通信。可以用于复杂计算的函数。比如大文件分片上传解析hash值。
```js
// main.js
const worker = new Worker('worker.js');

worker.postMessage('Hello, Worker!');

worker.onmessage = function(e) {
  console.log('从 Worker 收到的消息：', e.data);
};

```
2. Service Worker: 是一种特殊的 Web Worker，运行在后台，能够实现离线缓存、后台同步、推送通知等功能。
	- **缓存管理**：Service Workers 可以拦截网络请求并提供缓存资源，使得网站具有更快的加载速度和离线能力。
	- **后台同步**：允许在网络恢复时进行后台数据同步，提高用户体验。
	- **推送通知**：即使在浏览器关闭的情况下，也可以通过 Service Workers 向用户推送通知。
```js
// service-worker.js
self.addEventListener('install', (event) => {
  console.log('Service Worker 安装中。');
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});

```

3. WebAssembly:可以在浏览器中运行接近原生速度的代码。
特点：
-  **高性能**：WebAssembly 能以接近原生的速度执行计算密集型任务。
- **互操作性**：可以与 JavaScript 结合使用，允许开发者在前端利用其他语言的代码库。

4. Atomics和SharedArrayBuffer
**SharedArrayBuffer** 和 **Atomics** 提供了一种在线程之间共享内存的方法，使得真正的并行计算成为可能。
- **共享内存**：允许在主线程和 Worker 之间共享内存，适合高性能计算任务。
- **原子操作**：使用 Atomics 可以保证对共享数据的安全操作，避免竞态条件。
```js
// main.js
const buffer = new SharedArrayBuffer(1024);
const array = new Int32Array(buffer);
const worker = new Worker('worker.js');

worker.postMessage(buffer);

// worker.js
onmessage = function(e) {
  const array = new Int32Array(e.data);
  Atomics.add(array, 0, 10);
  console.log(Atomics.load(array, 0)); // 应该打印 10
};

```


**死锁是什么，为什么会引起死锁，其解决方案是什么**
死锁是指两个或多个进程（或线程）因竞争资源而相互等待，且都无法继续执行的一种状态。在这种情况下，这些进程（或线程）都在等待其他进程释放资源，而其他进程也在等待它们释放资源，导致所有进程都无法继续运行。

死锁发生的条件
1. 互斥条件：资源只能唯一占领，同一时间只能有一个进程使用某个资源
2. 持有并等待条件：进程至少拥有一个资源，同时又在等待获取一个或者多个其他进程占有的资源
3. 不可剥夺条件：资源不可被剥夺
4. 循环等待条件：存在一个进程链，使得每个进程都在等待下一个进程所占有的资源。

死锁的解决方案：
预防、避免、检测和恢复

预防：破坏死锁发生的四个条件即可

避免：银行家算法。实际上在计算机中资源的请求都是不可预知的，所有这个几乎不可能用在计算机上。


死锁的检测和恢复：
检测：定期或在资源请求被拒绝时，系统可以运行死锁检测算法，通过检测进程间的资源依赖图或使用检测矩阵等方法，判断是否存在死锁。
恢复：一旦检测到死锁，可以通过以下方式恢复系统：
- **终止进程**：选择一个或多个进程终止，以打破死锁循环。这种方式虽然简单，但可能会导致数据丢失或需要重启任务。（大多数会计算代价最小的进程）
- **资源抢占**：强制从死锁进程中剥夺某些资源，并将这些资源分配给其他进程，以打破循环。


HTTP/HTTPs的基本工作原理及其区别？如何确保前端应用的安全性？

### 性能相关
**白屏问题如何解决？**
1. 减少页面资源的加载时间：
	1. 优化资源大小
	2. 延迟加载非关键资源
	3. 懒加载图片视频
2. 提高首屏渲染时长
	1. 服务端渲染：解决白屏问题和SPA的SEO问题
	2. 骨架屏，css骨架屏
3. 优化DNS解析和网络请求
	1. DNS预解析：`<link rel="dns-prefetch" src="www.baidu"></link>`
		1. 这里是预先解析出来域名对应的IP地址
	2. CDN，使用全球内容分发网络对资源的加载优化
		1. 这里CDN加速是因为，CDN会根据IP所在地，调用最近的