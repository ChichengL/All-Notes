
1. ES6有哪些新特性：
let/const、箭头函数和Class类、模版字符串、解构赋值和展开运算符、默认参数、、for ... in/of 循环、map/set数据结构、Promise、Symbol
延展let/const/var有什么区别：var 是es6之前声明变量的操作符，let/const是es6及之后的。
他们的区别：
**var**
var声明的变量存在变量提升，这个变量提升在function声明函数时也会存在。
var声明的变量挂载到window（全局对象）上的，且不会被局部作用域所框束。

所以会存在一些问题比如：
```js
for(var i = 0; i < 10; i ++){
    setTimeout(()=>{console.log(i)});
}
```
这个打印10个10；
要想解决也很简单：1. 换为let，2.使用IFFE将变量保留

原因：每次循环都是一个局部作用域，因此每次的i是不同的，只在自己的作用域有效，所以打印出的值是当前作用域的值。（对于换为let）
对于换为IFFE，是因为相当于是一个闭包，保留了当前的值

**let/const**
let声明的变量可变，const声明的变量不可变。这里的可变与不可变并非绝对，对于const声明的基本类型是不可变的，而对于const声明的引用类型是可以变化的。
且这两个都会有TDZ（暂时性死区的存在），如果在声明之前使用就会报错。

**箭头函数和Class**
这两者的出现是为了解决函数的二义性，即可做函数也可做类。
箭头函数没有自己的this只能使用上一层的this
```js
const a = ()=>{
    console.log('a',this);
}
function b(){
    console.log('b',this);
}
a();
b();
```

在浏览器环境，两个打印的都是`window`,但是在node环境a打印的空对象，b打印的window。
因为a调用的时候没有自己的this，只会从外部上下文环境中获取，在nodejs中顶层代码的this指向空对象。对于普通函数的 `this` 取决于函数的调用方式。在顶层代码中直接调用 `b()`，`this` 指向的是全局对象。

class的作用：封装、继承、多态（面相对象的特性）

**模版字符串**
可以支持换行+字符占位
其大概实现：
```js
const year = '2024'
const month = '08'
const day = '19'
function render(str){
    return str.replace(/\$\{(\w+)\}/g,(match,key)=>{
        return eval(key);
    })
}
console.log(render('${year}-${month}-${day}'));
```

**解构赋值和展开运算符**

解构：数组解构，对象解构
```js
const arr = [1,2];
const [a,b] = arr;

const obj = {name:'1',age:18};
let objClone = { ...obj };
```
这里展开运算符可以做浅拷贝
浅拷贝的其他实现方案：Object.assign，手动实现浅拷贝，数组的slice，Array.from，concat方法也可以实现浅拷贝
拓展：深拷贝和浅拷贝区别
浅拷贝只拷贝数据，如果有引用类型，会导致共用一个引用类型，引发数据混乱的问题。
深拷贝实现
```js
const deepCopyOptimization = (obj) => {
    const cache = new WeakMap();
    const copy = (obj) => {
        if (typeof obj !== 'object' || obj === null) {
            return obj;
        }
        if (cache.has(obj)) {
            return cache.get(obj);
        }
        const newObj = Array.isArray(obj)? [] : {};
        cache.set(obj, newObj);
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                newObj[key] = copy(obj[key]);
            }
        }
        return newObj;
    }
    return copy(obj);
}
```
这个没有考虑map，set，symbol等数据结构。
获取Symbol需要使用`Object.getOwnPropertySymbols(obj)`

for...in/ of
for...in是用来遍历键的，针对于对象。
for...of是用来获取值的，只有实现了`Symbol.iterator`的才可以使用for...of来获取值
对象是不能使用for...of来获取值的，但是可以手动做到
```js
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        for(let key in this){
            yield key;
        }
    }
}
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        // for(let key in this){
        //     yield key;
        // }
        const keys = Object.keys(this); // 获取对象自身的所有键
        let index = 0;
        return {
            next: () => {
                if (index < keys.length) {
                    return { value: this[keys[index++]], done: false };
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
    }
}
for(let key in obj3){
    console.log(key)
}
for(let key of obj3){
    console.log(key)
}

```
这样for...in/of都可以遍历对象了。

