 ### ES6有哪些新特性：
let/const、箭头函数和Class类、模版字符串、解构赋值和展开运算符、默认参数、、for ... in/of 循环、map/set数据结构、Promise、Symbol
延展let/const/var有什么区别：var 是es6之前声明变量的操作符，let/const是es6及之后的。
他们的区别：
**var**
var声明的变量存在变量提升，这个变量提升在function声明函数时也会存在。
var声明的变量挂载到window（全局对象）上的，且不会被局部作用域所框束。

所以会存在一些问题比如：
```js
for(var i = 0; i < 10; i ++){
    setTimeout(()=>{console.log(i)});
}
```
这个打印10个10；
要想解决也很简单：1. 换为let，2.使用IFFE将变量保留

原因：每次循环都是一个局部作用域，因此每次的i是不同的，只在自己的作用域有效，所以打印出的值是当前作用域的值。（对于换为let）
对于换为IFFE，是因为相当于是一个闭包，保留了当前的值

**let/const**
let声明的变量可变，const声明的变量不可变。这里的可变与不可变并非绝对，对于const声明的基本类型是不可变的，而对于const声明的引用类型是可以变化的。
且这两个都会有TDZ（暂时性死区的存在），如果在声明之前使用就会报错。

**箭头函数和Class**
这两者的出现是为了解决函数的二义性，即可做函数也可做类。
箭头函数没有自己的this只能使用上一层的this
```js
const a = ()=>{
    console.log('a',this);
}
function b(){
    console.log('b',this);
}
a();
b();
```

在浏览器环境，两个打印的都是`window`,但是在node环境a打印的空对象，b打印的window。
因为a调用的时候没有自己的this，只会从外部上下文环境中获取，在nodejs中顶层代码的this指向空对象。对于普通函数的 `this` 取决于函数的调用方式。在顶层代码中直接调用 `b()`，`this` 指向的是全局对象。

class的作用：封装、继承、多态（面相对象的特性）

**模版字符串**
可以支持换行+字符占位
其大概实现：
```js
const year = '2024'
const month = '08'
const day = '19'
function render(str){
    return str.replace(/\$\{(\w+)\}/g,(match,key)=>{
        return eval(key);
    })
}
console.log(render('${year}-${month}-${day}'));
```

**解构赋值和展开运算符**

解构：数组解构，对象解构
```js
const arr = [1,2];
const [a,b] = arr;

const obj = {name:'1',age:18};
let objClone = { ...obj };
```
这里展开运算符可以做浅拷贝
浅拷贝的其他实现方案：Object.assign，手动实现浅拷贝，数组的slice，Array.from，concat方法也可以实现浅拷贝
拓展：深拷贝和浅拷贝区别
浅拷贝只拷贝数据，如果有引用类型，会导致共用一个引用类型，引发数据混乱的问题。
深拷贝实现
```js
const deepCopyOptimization = (obj) => {
    const cache = new WeakMap();
    const copy = (obj) => {
        if (typeof obj !== 'object' || obj === null) {
            return obj;
        }
        if (cache.has(obj)) {
            return cache.get(obj);
        }
        const newObj = Array.isArray(obj)? [] : {};
        cache.set(obj, newObj);
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                newObj[key] = copy(obj[key]);
            }
        }
        return newObj;
    }
    return copy(obj);
}
```
这个没有考虑map，set，symbol等数据结构。
获取Symbol需要使用`Object.getOwnPropertySymbols(obj)`

for...in/ of
for...in是用来遍历键的，针对于对象。
for...of是用来获取值的，只有实现了`Symbol.iterator`的才可以使用for...of来获取值
对象是不能使用for...of来获取值的，但是可以手动做到
```js
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        for(let key in this){
            yield key;
        }
    }
}
const obj3 = {
    [Symbol('a')]:'b',
    c:1,
    [Symbol.iterator]:function*(){
        // for(let key in this){
        //     yield key;
        // }
        const keys = Object.keys(this); // 获取对象自身的所有键
        let index = 0;
        return {
            next: () => {
                if (index < keys.length) {
                    return { value: this[keys[index++]], done: false };
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
    }
}
for(let key in obj3){
    console.log(key)
}
for(let key of obj3){
    console.log(key)
}

```
这样for...in/of都可以遍历对象了。


**Promise**
一文弄懂[Promise](http://www.chichengl.xyz/archives/yi-wen-nong-dong-promiseji-qi-shou-xie)


### Vue
Vue2和Vue3的区别在哪里：
- api——组合式与选项式：更加细腻的api，如shallowRef
- 响应式的重构
   - vue2：defineProperty
   - vue3：proxy
- 内置组件的变化
   - **新增了：Fragment、Teleport（vue3.2及之前的版本是有内存泄露的风险）、Suspense**
- **生命周期的变化**
- diff算法的优化
- **类型安全**
   - vue3支持了ts
- **模块化**
   - vue2默认是webpack
   - vue3默认是vite
- **vue3新增了tree-shaking**

响应式本质是：数据与函数的联动，数据变化催发函数执行的过程。
响应式的实现：defineProperty，Proxy，观察者模式+发布订阅

VueRouter有了解吗？VueRouter有两种模式，hash模式和history模式
router和route的区别：
router：是操作路由的对象，可以通过router进行函数式对路由进行函数式操作
route是路由元信息，存储着当前路由下的query等信息。

了解过Vue-cli，还了解过webpack和vite？
vue-cli的是什么，vue-cli是一个基于webpack的脚手架，便于快速搭建vue等项目。

webpack和vite都是打包构建工具，webpack出现时间更早，生态更加成熟，但是是基于js所编写，其天然对js有打包能力，其他对图片的打包需要通过相对应的loader来实现。
vite出现时间稍晚，但是其打包速度以及热更新速度很快，其生态也愈发完善。

vite为什么比webpack更快，有什么优势?
Vite基于rollup+esmodule，在开发阶段的打包构建，是“no bundle的”没有打包这个概念，让浏览器全权决定打包，其次他的热更新是定点更新，一个文件更新，只有其他依赖了这个文件的文件才会一同更新，而非类似于webpack全量的再去递归寻找依赖关系进而更新