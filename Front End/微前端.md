## 微前端——小窥
### 微前端解决了什么
管理后台型应用往往页面重复率高，一些公司为了降低开发成本，本身可能会衍生出一些可复用性高的技术框架或者建设低代码搭建平台，从而用于快速开发并减少产研成本。
但是使用低代码平台需要这些：
- 新增的应用在建设时，为了保持体验的一致性，不得不在低代码平台进行开发；
- SPA 应用模式不变的情况下，已有应用无法和低代码应用进行灵活集成并保持体验一致性；
- **低代码应用可能存在开发和性能优化瓶颈**，后期业务方希望渐渐去除低代码页面进行重构。

为了解决这一问题，需要有新的方案
-  可以让新增应用不依赖低代码进行开发，使用自己的技术栈，支持独立部署；
- 可以让已有的后台应用做少量改造就可以集成到现有的管理后台，支持独立部署；
- 新的业务可以使用新的技术栈进行开发，可以混合低代码方案进行开发；
- 对于性能较差且实在无法继续在低代码平台进行优化的页面，可以逐步进行技术栈重构。

此时采用微前端是一个合适的技术选型，它可以具备如下特性：
-   **SPA 体验**：微前端可以使所有的应用保持原有的 SPA 体验，统一品牌认知；
-   **技术栈无关**：可以使用不同的技术栈（例如 React、Vue、Svelte ）开发，支持独立部署；
-   **性能优化：** 在 MPA 和 iframe 中如果想要做性能优化，往往需要依赖浏览器和 HTTP 的能力，而在微前端中可以处理应用资源的去重、应用自身的预加载、预渲染和缓存处理，也可以对已加载的页面进行保活处理，增加了性能优化的手段；
-   **解耦重构**：部分低代码页面无法满足性能要求时，可以通过新的技术栈将页面进行重构，不影响其他低代码页面的运行，从而可以减少重构带来的影响面。

**微前端可以降低大型复杂应用的开发、升级、维护以及团队协作的成本。当然，解决历史遗留的难以开发、升级和维护的大型应用，也是使用微前端的一个重要原因。**
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c950f9dd92947028a88c825df2c407a~tplv-k3u1fbpfcp-watermark.image?)

当然，**微前端的框架更多是关注于在浏览器中如何实现各个模块应用的集成**，而不仅仅是依赖服务端的解决方案（例如 MPA）

微前端出现的业务场景
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8570e3c1c42449999a5eb6e72df2fe41~tplv-k3u1fbpfcp-watermark.image?)


### 微前端的特征
在聚合的过程中需要一个容器应用（在微前端里称作主应用），主应用通过设计导航将各个拆分的小型应用（在微前端里称作微应用）聚合在一起，可以根据导航进行微应用的切换。

拆分的微应用需要具备**独立开发、独立部署和独立运行的特性：**


- 微应用可以采用不同的技术栈，支持**独立开发；**
- 微应用可以单独部署到不同的服务器上，支持**独立部署；**
- 微应用的运行可以不依赖其他微应用，支持**独立运行。**

如果项目本身采用 SPA 模式进行开发，则可以通过以下方案进行微前端改造：

-   基于 NPM 包的微前端：将微应用打包成独立的 NPM 包，然后在主应用中安装和使用；
-   基于代码分割的微前端：在主应用中使用懒加载技术，在运行时动态加载不同的微应用；
-   基于 Web Components 的微前端：将微应用封装成自定义组件，在主应用中注册使用；
-   基于 Module Federation 的微前端：借助 Webpack 5 的 Module Federation 实现微前端；
-   基于动态 Script 的微前端：在主应用中动态切换微应用的 Script 脚本来实现微前端；
-   基于 iframe 的微前端：在主应用中使用 iframe 标签来加载不同的微应用；
-   基于框架（JavaScript SDK）的微前端：使用 single-spa、qiankun、wujie 等通用框架。

接下来就一一了解


#### iframe
iframe 是常用的微前端设计方案之一

**铺垫**

浏览器的架构：浏览器是一个多进程架构
![](Public%20Image/Pasted%20image%2020240810171630.png)

浏览器的沙箱隔离
由于 Web 应用运行在 Renderer 进程中，浏览器为了提升安全性，需要通过常驻的 Browser 主进程对 Renderer 进程进行沙箱隔离设计，从而实现 Web 应用进行隔离和管控

Chrome 浏览器在进行沙箱设计时，会尽可能的复用现有操作系统的沙箱技术，例如以 Windows 操作系统的沙箱架构为例，**所有的沙箱都会在进程粒度进行控制**，所有的进程都通过 IPC 进行通信。在 Windows 沙箱的架构中，存在一个 Broker 进程和多个 Target 进程， Broker 进程主要用于派生 Target 进程、管理 Target 进程的沙箱策略、代理 Target 进程执行策略允许的操作，而所有的 Target 进程会在运行时受到沙箱策略的管控



浏览器的站点隔离