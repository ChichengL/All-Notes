

# DNS
DNS是域名系统，其作用是：将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的IP 地址。
比如www.baidu.com为主机名。但是要说他的IP地址又有几个人知道呢？
虽然IP方便传输数据，但是不方便记忆，因此出现了DNS


DNS同时使用TCP和UDP协议
**DNS占用53号端口，同时使用TCP和UDP协议。**
（1）在区域传输的时候使用TCP协议
- 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
- TCP是一种可靠连接，保证了数据的准确性。





（2）在域名解析的时候使用UDP协议
- 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，`用UDP传输即可`。不用经过三次握手，`这样DNS服务器负载更低，响应更快`。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

DNS的完整流程
- 首先会在**浏览器的缓存**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
- 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
- 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
- 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
- 本地DNS服务器将返回结果保存在缓存中，便于下次使用
- 本地DNS服务器将返回结果返回给浏览器

DNS解析
DNS解析是一个包含迭代查询和递归查询的过程
- `递归查询`：是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。
- `迭代查询`：是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。


# TCP和UDP




其区别

|        |                        |                            |
| ------ | ---------------------- | -------------------------- |
|        | UDP                    | TCP                        |
| 是否连接   | 无连接                    | 面向连接                       |
| 是否可靠   | 不可靠传输，不使用流量控制和拥塞控制     | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信  | 只能是一对一通信                   |
| 传输方式   | 面向报文                   | 面向字节流                      |
| 首部开销   | 首部开销小，仅8字节             | 首部最小20字节，最大60字节            |
| 适用场景   | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输        |

应用：
TCP：效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

UDP：率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。


小Tips，TCP保证数据可靠采用了以下机制
>1. `序列号和确认应答`，TCP为每个发送的数据包分配一个序列号，接收方会对收到的数据包发送带有确认序列号的ACK响应。
>2. `超时重传`：如果发送方在预期时间内没有收到特定数据包的确认，它将认为该数据包丢失或损坏，并重新发送该数据包。TCP实现中使用了重传计时器来检测超时事件。
>3. `检验和`：TCP头包含一个校验和字段，用于检测数据在传输过程中是否受损。接收方对接收到的数据进行校验，如果`校验和不匹配，则数据包被丢弃`，并通过不发送ACK来触发发送方重传。
>4. `流量控制`：TCP使用滑动窗口协议来控制数据的发送速率，以避免拥塞和数据丢失。接收方会告知发送方其接收缓冲区的可用空间大小，发送方据此调整发送速率，从而避免数据发送过快导致接收方无法处理。
>5. `拥塞控制`：TCP根据网络状况动态调整其发送速率，以避免网络拥塞。当网络开始出现拥塞迹象时，TCP会减少其数据的发送速率，使用`慢启动、拥塞避免`、快速重传和快速恢复等算法来管理数据流。
>6. `连接管理`：TCP使用三次握手建立连接，确保双方都准备好进行通信，并使用四次挥手断开连接，确保数据的有序关闭，且双方都确认没有更多数据待发送。
>
>   三次握手
>   ![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663256-5eb6dcdf-fdb6-4b67-a3da-da15c1d396fb.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_680%2Climit_0)
>   采用三次握手的原因，如果采用二次握手会怎么办
>   >如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。
>   总结：TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。` 第三次握手的作用是客户端对服务器端的初始序号的确认`。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。
>   
>   四次挥手
>   ![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663279-0ea063ba-a06b-4f57-9aa9-0e2d1c8d373c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_680%2Climit_0)
>   采用四次挥手的原因
>   >因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。
>   TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。
>   最后一次挥手中，客户端会等待一段时间再关闭的原因，`是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。`
>![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952153-a7106d22-225d-4081-9b0a-56b0d1876bc2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_750%2Climit_0)



# HTTP协议
HTTP协议概述
HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。
HTTP协议具有以下**优点**：

- 支持客户端/服务器模式
- **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
- **无连接**：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间。
- **无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
- **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
因为是无状态的，那么确认不了这次请求的发起者是哪一个。因此需要携带Cookie
  

HTTP协议具有以下**缺点**：
- **无状态**：HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
- **明文传输**：协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
- **不安全**

（1）**通信使用明文**（不加密），内容可能会被窃听
（2）不验证通信方的身份，因此有可能遭遇伪装
（3）无法证明报文的完整性，所以有可能已遭篡改

HTTP协议连接模式有两种：持续连接和非持续连接

在`HTTP/1.0`时期，每发起一个请求都需要新建一次TCP连接，因为每次TCP连接收需要三次握手和四次挥手，这种方式增大了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。

在`HTTP/1.1`之后提出了长连接的通信方式（这个协议也是目前网站应用最为多的协议之一），长连接让管道网络传输成为了可能。
管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
那么这样会造成什么样的问题呢？
服务器还是按照顺序回应请求，要是前面的回应特别慢，那么后面就会有许多请求排队等候——即队头阻塞

堵头阻塞的解决方法：
（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。

（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。


HTTP协议版本
### HTTP/0.9 
只支持GET请求，且不包含任何头部信息或者状态码,客户端向服务器发送请求时，只需提供一个简单的请求行，如`GET /index.html`，服务器则直接返回HTML内容，不附加任何额外信息。

### HTTP/1.0
正式引入了请求头、响应头和状态码，使得HTTP协议更加规范和灵活。状态码如200 OK、404 Not Found等，能够帮助客户端理解请求的结果。
除了GET之外，还新增了`POST、HEAD等方法`，丰富了与服务器交互的方式。
通过请求头中的Accept字段，客户端可以告知服务器它能接受的内容类型，从而实现内容的按需提供。

首次引入了`基本的缓存机制`，通过Expires和Cache-Control等头部字段，可以指示资源的缓存策略。
虽然HTTP 1.0本身是无状态的，但它通过Cookie等机制支持了跨请求的状态管理。
默认情况下，HTTP 1.0中的每个请求/响应都会创建一个新的TCP连接，然后关闭，这导致了较高的延迟和资源消耗。
因此在HTTP/1.1诞生了

### HTTP/1.1
更新了长连接，在请求头设置一个`Connection:keep-alive`就可以进行长连接

该版本还引入了管道机制，即在一个TCP连接里，客户端可以同时发送多个请求，不需要等收到上一个请求回应，就可以发送新的请求，但是请求的响应还是按照请求发送的顺序返回的，这样就进一步提高了HTTP协议的效率。但是引发了队头阻塞的问题

- 加入了新的**请求方法**：**PUT、PATCH、HEAD、 OPTIONS、DELETE**
- 加入了**缓存机制**：**强缓存**和**协商缓存**
- 客户端请求的头部信息**加入了**`**Host**`**字段**，用来指定服务器的域名，这样就可以区分同一个物理主机中的不同虚拟主机的域名


### HTTP/2.0
HTTP/2.0是一个二进制协议，在HTTP/1.1版本中，报文头信息必须是文本（ASCII编码），数据体可以是文本，可以说二进制。而HTTP/2.0头信息和数据提都是二进制，统称为帧
- **数据流**：HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的 请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。`每 个数据流都有一个独一无二的编号`。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。

HTTP/2.0还采用了头信息压缩

HTTP/2 协议**缺点**：`因为 HTTP/2 使用了多路复用`，一般来说同一域名下只需要使用一个TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。`只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去`，这样就导致了后面的所有数据都会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。



### HTTP/3.0
HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。
![](https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-9b0f553d-3c6e-43a3-8185-8565f9fa1fb4.webp?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_750%2Climit_0)
1. 流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。
2. 集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。
3. 多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。
4. 快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。


# HTTPS
HTTPS时一种透过计算机忘了进行安全通信的传输协议。
HTTP进行通信，但是利用SSL/TLS来加密数据包。
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/22/167d48bc77ee69f8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)
- 1、TCP 三次同步握手
- 2、客户端验证服务器数字证书
- 3、DH 算法协商对称加密算法的密钥、hash 算法的密钥
- 4、SSL 安全加密隧道协商完成
- 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。
其实使用 HTTPS 最主要的用处是以下两点：

- 建立一个信息安全通道，来保证数据传输的安全
- 确认网站的真实性，防止钓鱼网站

### HTTP 与 HTTPS 的区别

- HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密
- HTTP 的端口号是 80，HTTPS 是 443
- HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费
- HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

HTTPS的来源：
总所周知，HTTP是明文传输，那么明文传输存在一些问题，在传输过程中会被数据会被劫持还可能被修改。
因此推出使用加密算法对内容进行加密。

常见的加密算法有`对称加密和非对称加密`

### 对称加密
即`加密解密都为一个密钥`


这个对称密钥也是先掌握到一个人手中的，然后通过网络通信明文发出去。
如果这个密钥被劫持了，那么其他的人也可以对加密后的信息进行解密、修改
![](Pasted%20image%2020240507201532.png)
缺点：
所以这种对称密钥的弊端就是，可能被中间人拦截，这样中间人就可以获取到了密钥，就可以对传输的信息就行窥视和篡改。

### 非对称加密
最常用的是RSA非对称加密
双方必须协商一对密钥，一个公钥一个私钥。用私钥加密数据，只能公钥解开。用公钥加密数据，只能私钥解开。
私钥在内部存储，`绝不可泄露`，公钥任何人都可以拥有。
![](../Pasted%20image%2020240507201443.png)
那么这里可以说是完美了

但是RSA对称加密算法的速度`非常慢`，只适合小数据传输

因此HTTPS采用的是非对称加密+对称加密的结合。

### 非对称加密+对称加密
**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。

发送密文的一方，使用对方的`公钥处理`”对称密钥“，然后另一端用私钥解密，拿到对称密钥，后面通过对称密钥对信息进行加密和解密。
这样即保证了安全又保证了速度![](Pasted%20image%2020240507202640.png)
![](Pasted%20image%2020240507202640.png)


这里确认了能够正确传输，而且保障了安全性。
但是还有问题有待解决——可能拿到"公钥"和服务端配对的"密钥"不是同一套。

比如A给B发消息前，A想要拿到B的公钥，但是被神秘人劫持，神秘人给A发了错误的"公钥"，然后伪装为服务器，骗取A的各种信息。
为了避免这种情况，因此推出了`数字证书`，来表明正确的身份。


![](Pasted%20image%2020240507203457.png)
CA就是颁发证书的机构

然后如何鉴别？
拿到数字证书之后，使用同样的hash算法 ，得到信息摘要，然后使用CA的公钥对数字签名进行解密，得到CA创建的消息摘要，进行对比。

数字签名的 作用
- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
- 数字签名能确定消息的完整性,证明数据是否未被篡改过。

HTTPS的工作流程
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/22/16a45839ceacbb52~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)
