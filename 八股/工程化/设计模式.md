
设计模式往往代表着最佳实践，是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。

设计模式的原则有如下
- **S 单一职责原则**
	-  一个程序只做好一件事
	- 如果功能过于复杂就拆分开，每个部分保持独立
- - **O  开放/封闭原则**
    - 对扩展开放，对修改封闭
    - 增加需求时，扩展新代码，而非修改已有代码
- L  里氏替换原则
    - 子类能覆盖父类
    - 父类能出现的地方子类就能出现
- I  接口隔离原则
    - 保持接口的单一独立
    - 类似单一职责原则，这里更关注接口
- D  依赖倒转原则
    - 面向接口编程，依赖于抽象而不依赖于具体
    - 使用方只关注接口而不关注具体类的实现


## 创建型
分为：单例模式、原型模式、工厂模式、抽象工厂模式、建造者模式

### 工厂模式
工厂模式定义一个`用于创建对象的接口`，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。

比如：汉堡王负责生产汉堡，小明只用关心有没有汉堡，而不用关心汉堡是如何制作的。

```js
class Product {
    constructor(name) {
        this.name = name
    }
    init() {
        console.log('init')
    }
    fun() {
        console.log('fun')
    }
}

class Factory {
    create(name) {
        return new Product(name)
    }
}

// use
let factory = new Factory()
let p = factory.create('p1')
p.init()
p.fun()
```


适用场景：
- 如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择
- 将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；
- 需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性
