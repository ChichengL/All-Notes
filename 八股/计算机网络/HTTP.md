# HTTP协议
HTTP协议概述
HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。
HTTP协议具有以下**优点**：

- 支持客户端/服务器模式
- **简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。
- **无连接**：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间。
- **无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
- **灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
因为是无状态的，那么确认不了这次请求的发起者是哪一个。因此需要携带Cookie
  

HTTP协议具有以下**缺点**：
- **无状态**：HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
- **明文传输**：协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
- **不安全**

（1）**通信使用明文**（不加密），内容可能会被窃听
（2）不验证通信方的身份，因此有可能遭遇伪装
（3）无法证明报文的完整性，所以有可能已遭篡改

HTTP协议连接模式有两种：持续连接和非持续连接

在`HTTP/1.0`时期，每发起一个请求都需要新建一次TCP连接，因为每次TCP连接收需要三次握手和四次挥手，这种方式增大了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。

在`HTTP/1.1`之后提出了长连接的通信方式（这个协议也是目前网站应用最为多的协议之一），长连接让管道网络传输成为了可能。
管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
那么这样会造成什么样的问题呢？
服务器还是按照顺序回应请求，要是前面的回应特别慢，那么后面就会有许多请求排队等候——即队头阻塞

堵头阻塞的解决方法：
（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。

（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。


HTTP协议版本
### HTTP/0.9 
只支持GET请求，且不包含任何头部信息或者状态码,客户端向服务器发送请求时，只需提供一个简单的请求行，如`GET /index.html`，服务器则直接返回HTML内容，不附加任何额外信息。

### HTTP/1.0
正式引入了请求头、响应头和状态码，使得HTTP协议更加规范和灵活。状态码如200 OK、404 Not Found等，能够帮助客户端理解请求的结果。
除了GET之外，还新增了`POST、HEAD等方法`，丰富了与服务器交互的方式。
通过请求头中的Accept字段，客户端可以告知服务器它能接受的内容类型，从而实现内容的按需提供。

首次引入了`基本的缓存机制`，通过Expires和Cache-Control等头部字段，可以指示资源的缓存策略。
虽然HTTP 1.0本身是无状态的，但它通过Cookie等机制支持了跨请求的状态管理。
默认情况下，HTTP 1.0中的每个请求/响应都会创建一个新的TCP连接，然后关闭，这导致了较高的延迟和资源消耗。
因此在HTTP/1.1诞生了

### HTTP/1.1
更新了长连接，在请求头设置一个`Connection:keep-alive`就可以进行长连接

该版本还引入了管道机制，即在一个TCP连接里，客户端可以同时发送多个请求，不需要等收到上一个请求回应，就可以发送新的请求，但是请求的响应还是按照请求发送的顺序返回的，这样就进一步提高了HTTP协议的效率。但是引发了队头阻塞的问题

- 加入了新的**请求方法**：**PUT、PATCH、HEAD、 OPTIONS、DELETE**
- 加入了**缓存机制**：**强缓存**和**协商缓存**
- 客户端请求的头部信息**加入了**`**Host**`**字段**，用来指定服务器的域名，这样就可以区分同一个物理主机中的不同虚拟主机的域名


### HTTP/2.0
HTTP/2.0是一个二进制协议，在HTTP/1.1版本中，报文头信息必须是文本（ASCII编码），数据体可以是文本，可以说二进制。而HTTP/2.0头信息和数据体都是二进制，统称为帧
- **数据流**：HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的 请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。`每 个数据流都有一个独一无二的编号`。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。

HTTP/2.0还采用了头信息压缩

HTTP/2 协议**缺点**：`因为 HTTP/2 使用了多路复用`，一般来说同一域名下只需要使用一个TCP 连接。由于多个数据流使用同一个 TCP 连接，遵守同一个流量状态控制和拥塞控制。`只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去`，这样就导致了后面的所有数据都会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。



### HTTP/3.0
HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。
![](https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-9b0f553d-3c6e-43a3-8185-8565f9fa1fb4.webp?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_750%2Climit_0)
1. 流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。
2. 集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。
3. 多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。
4. 快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。


# HTTPS
HTTPS时一种透过计算机忘了进行安全通信的传输协议。
HTTP进行通信，但是利用SSL/TLS来加密数据包。
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/22/167d48bc77ee69f8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)
- 1、TCP 三次同步握手
- 2、客户端验证服务器数字证书
- 3、DH 算法协商对称加密算法的密钥、hash 算法的密钥
- 4、SSL 安全加密隧道协商完成
- 5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。
其实使用 HTTPS 最主要的用处是以下两点：

- 建立一个信息安全通道，来保证数据传输的安全
- 确认网站的真实性，防止钓鱼网站

### HTTP 与 HTTPS 的区别

- HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密
- HTTP 的端口号是 80，HTTPS 是 443
- HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费
- HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

HTTPS的来源：
总所周知，HTTP是明文传输，那么明文传输存在一些问题，在传输过程中会被数据会被劫持还可能被修改。
因此推出使用加密算法对内容进行加密。

常见的加密算法有`对称加密和非对称加密`

### 对称加密
即`加密解密都为一个密钥`


这个对称密钥也是先掌握到一个人手中的，然后通过网络通信明文发出去。
如果这个密钥被劫持了，那么其他的人也可以对加密后的信息进行解密、修改
![](PublicImage/Pasted%20image%2020240507201532.png)
缺点：
所以这种对称密钥的弊端就是，可能被中间人拦截，这样中间人就可以获取到了密钥，就可以对传输的信息就行窥视和篡改。

### 非对称加密
最常用的是RSA非对称加密
双方必须协商一对密钥，一个公钥一个私钥。用私钥加密数据，只能公钥解开。用公钥加密数据，只能私钥解开。
私钥在内部存储，`绝不可泄露`，公钥任何人都可以拥有。
![](PublicImage/Pasted%20image%2020240507201443.png)
那么这里可以说是完美了

但是`RSA对称加密算法`的速度`非常慢`，只适合小数据传输

因此HTTPS采用的是非对称加密+对称加密的结合。

### 非对称加密+对称加密
**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。

发送密文的一方，使用对方的`公钥处理`”对称密钥“，然后另一端用私钥解密，拿到对称密钥，后面通过对称密钥对信息进行加密和解密。
这样即保证了安全又保证了速度![](PublicImage/Pasted%20image%2020240507202640.png)
![](PublicImage/Pasted%20image%2020240507202640.png)


这里确认了能够正确传输，而且保障了安全性。
但是还有问题有待解决——可能拿到"公钥"和服务端配对的"密钥"不是同一套。

比如A给B发消息前，A想要拿到B的公钥，但是被神秘人劫持，神秘人给A发了错误的"公钥"，然后伪装为服务器，骗取A的各种信息。
为了避免这种情况，因此推出了`数字证书`，来表明正确的身份。


![](PublicImage/Pasted%20image%2020240507203457.png)
CA就是颁发证书的机构

然后如何鉴别？
拿到数字证书之后，使用同样的hash算法 ，得到信息摘要，然后使用CA的公钥对数字签名进行解密，得到CA创建的消息摘要，进行对比。

数字签名的 作用
- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
- 数字签名能确定消息的完整性,证明数据是否未被篡改过。

HTTPS的工作流程
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/22/16a45839ceacbb52~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)



# HTTP缓存
HTTP缓存存在两种：`from memory cache`和`from disk cache`
分别是来自内存和来自磁盘的缓存


## 前端常用缓存方案
- HTML 文档配置协商缓存
- JS、CSS、图片等资源配置强缓存
此方案的好处：当项目版本更新时，可以获取最新的页面；若版本未变化，可继续复用之前的缓存资源；既很好利用了浏览器缓存，又解决了页面版本更新的问题

浏览器拉取缓存流程
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/504787d34e1d41379d2d8a3754998810~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

## 强缓存
资源没有过期就直接取缓存。如果过期了，则请求服务器，一般用于JS、CSS、图片等资源

第一次访问页面，浏览器会根据服务器返回的response Header来判断是否对资源进行缓存，如果响应头中有`cache-control` 或 `expires`字段，那么就代表强缓存



## Cache-Control
是响应头头中控制网页缓存的字段，主要取值为：
- public：资源客户端和服务器都可以缓存
- privite：资源只有客户端可以缓存
- no-cache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证
- no-store：不使用缓存
- max-age：缓存保质期，是相对服务器的时间
max-age
比如HTTP响应头中`Cache-Control为max-age = 31536000`，即表示在31536000秒后该资源过期，如果没有过期，浏览器会直接使用缓存结果，强制缓存生效。

**Cache-Control: no-cache 和 no-store的区别：**

`Cache-Control: no-cache`：这个很容易让人产生误解，误以为是响应不被缓存

实际上`Cache-Control: no-cache` 是会被缓存的，是协商缓存的标识，只不过每次都会向服务器发起请求，来验证当前缓存的有效性

`Cache-Control: no-store`：这个才是响应不被缓存的意思

## Expires
Expires是http1.0控制网页缓存的字段，值为一个时间戳，服务器返回该资源缓存的到期时间
但 Expires 有个缺点，就是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的

到了HTTP/1.1，Expire 已经被 Cache-Control 替代，Cache-Control 使用了max-age相对时间，解决了Expires 的缺陷

因此。当Expire和Cache-Control都存在的时候后者的优先级更高。


## memory cache 和 disk cache 的区别
两者都属于**强缓存**，主要区别在于存储位置和读取速度上
- memory cache来自内存，disk cache来自于磁盘
- memory cache要比 disk cache快的多！从磁盘访问可能需要5-20ms，而从内存访问只需要100ns
特点
- memory cache 特点：  
    当前tab页关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，原来的 memory cache 会变成 disk cache
- disk cache 特点：  
    关闭tab页甚至关闭浏览器后，数据依然存在，下次打开仍然会是 from disk cache

  
一般情况下，浏览器会将js和图片等文件解析执行后直接存入内存中，这样当刷新页面时，只需直接从内存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)
从使用频率而言，js和图片在页面加载时经常被频繁请求，且在交互过程中可能需要快速访问，因此放入内存中（`为了JS的快速加载和图片的快速呈现`即为了增强用户体验感）


## 协商缓存
浏览器携带缓存标识向服务器发送请求，服务器根据缓存标识来决定该资源是否过期，一般用于html资源，验证版本是否更新

触发条件
- Cache-Control 的值为 no-cache （协商缓存）
- 或者 Cache-Control: max-age=0

协商缓存的标识
### Last-modified
文件在服务器最后被修改的时间，从服务器response Headers上获取
Last-modified的验证流程
- 第一次访问页面，服务器的响应头会返回Last-Modified字段
- 客户端再次发送该请求时，请求头`If-Modified-Since`字段会携带上次请求返回的Last-Modified值
- 服务器根据`If-Modified-since`的值与该资源在服务器最后被修改的时间做对比，若服务器上的时间大于Last-Modified的值，则从小返回资源，表示资源已经更新；否则返回，表示资源未更新。


### Etag
当前资源文件的一个唯一标识(由服务器生成)，若文件内容发生变化该值就会改变
验证流程
- 第一次访问页面时，服务器的响应头会返回 etag 字段
- 客户端再次发起该请求时，**请求头 If-None-Match 字段会携带上次请求返回的 etag 值**
- 服务器根据 If-None-Match 的值，与该资源在服务器的Etag值做对比，若值发生变化，状态码为200，表示资源已更新；反之则返回304，代表资源无更新，可继续使用缓存

Etag出现是为了解决Last-modified带来的问题。
- 比如文件内容没有更改，只是做了一些其他的修改，那么不用重新请求。
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag 就能够保证这种需求下客户端在 1 秒内能刷新 N 次 cache

协商缓存存在两种状态
资源没变化返回304，反之返回200

因为Etag是为了解决Last-modified带来的问题，因此Etag的判断优先级是大于Last-modified

协商缓存的流程
第一次请求
客户端发送请求，服务器处理请求，返回文件内容和一堆Header，包括Etag 和 Last-Modified，状态码200
第二次请求
1、客户端发起请求，此时请求头上会带上 **if-none-match值为Etag** 和 **if-modified-since值为last-modified**

2、服务器优先判断 Etag，若资源未变化状态码为304，客户端继续使用本地缓存，若资源发生变化，状态码为200 并返回最新的资源


# WebScoket

### WebSocket出现的背景

WebSocket的出现，使得浏览器具备了实时双向通信的能力。本文由浅入深，介绍了WebSocket如何建立连接、交换数据的细节，以及数据帧的格式。
WebSocket出现之前，使用轮询的操作，实现“实时的效果”，但是这种占用资源及其明显

## 什么是WebSocket
HTML5开始提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道
特点：
- WebSocket可以在浏览器中使用
- 支持双向通信
- 使用简单

优点：
- 支持双向通信，实时性更强
- 更好的二进制支持（HTTP/2.0也是二进制协议）
- 少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。
- 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）

  
## 使用

### 服务端
```js
var app = require('express')();
var server = require('http').Server(app);
var WebSocket = require('ws');

var wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function connection(ws) {
    console.log('server: receive connection.');
    
    ws.on('message', function incoming(message) {
        console.log('server: received: %s', message);
    });

    ws.send('world');
});

app.get('/', function (req, res) {
  res.sendfile(__dirname + '/index.html');
});

app.listen(3000);

```

## 客户端
```html
<script>
  var ws = new WebSocket('ws://localhost:8080');
  ws.onopen = function () {
    console.log('ws onopen');
    ws.send('from client: hello');
  };
  ws.onmessage = function (e) {
    console.log('ws onmessage');
    console.log('from server: ' + e.data);
  };
</script>

```


### 建立连接过程

1. 客户端协议升级
   客户端发起协议升级请求，采用的是HTTP报文格式（只支持`GET`）
其首部信息
```http
GET / HTTP/1.1
Host: localhost:8080
Origin: http://127.0.0.1:3000
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==

```

`Connection：Upgrade`表示需要升级协议
`Upgrade:webSocket`标识升级到webSocket协议
`Sec-WebSocket-Version`标表示webSocket的协议
`Sec-WebSocket-key`：基础的防护


2. 服务端：响应协议升级
服务端返回内容 状态代码`101`表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。
```http
HTTP/1.1 101 Switching Protocols
Connection:Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=


```

3. Sec-WebSocket-Accept的计算

计算公式为：
1. 将`Sec-WebSocket-Key`跟`258EAFA5-E914-47DA-95CA-C5AB0DC85B11`拼接。
2. 通过SHA1计算出摘要，并转成base64字符串。


## 连接保持+心跳

WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。

但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。

  
为什么需要心跳机制？
1. **检测连接状态**：网络环境复杂多变，客户端或服务器可能因网络问题、系统重启等原因意外断开连接。心跳机制通过定期发送小数据包（心跳包）来检测连接是否仍然存活。
    
2. **避免超时断开**：许多网络设备和中间件（如防火墙、代理服务器）为了管理资源，会对长时间无数据传输的连接实施超时断开策略。心跳包可以防止这种无数据传输导致的连接中断。
    
3. **资源管理**：服务器可以根据心跳响应情况，管理连接资源，及时释放不再活跃的连接，避免资源浪费。

工作方式：
1. **客户端与服务器约定**：在WebSocket连接建立后，双方会约定心跳的发送间隔（如每隔30秒或1分钟）以及心跳的具体格式（通常是特定的控制帧或简单数据包）。
2. **定期发送心跳**：客户端和服务器都会按照约定的时间间隔定期发送心跳包。通常情况下，心跳包非常轻量，可能只是一个特定的控制字符或一个空的消息体。
3. **接收方确认**：当一方接收到心跳包时，会立即回复一个心跳响应，确认连接状态正常。这确保了双向通信链路的畅通。
4. **处理心跳失败**：如果在预定时间内未收到对方的心跳响应，发送方将认为连接已断开，并执行相应的重连逻辑或通知应用层连接异常。重连机制旨在自动恢复中断的连接，保持服务连续性。


实现细节
- **心跳间隔**：心跳间隔的选择需权衡资源消耗和连接健壮性。间隔太短会增加网络负担，太长则可能无法及时发现断线。

- **心跳数据**：心跳数据可以是任何双方约定的标识符，但通常为最小化的数据以减少带宽占用。    
- **错误处理**：实现心跳机制时，要考虑到网络波动导致的心跳延迟或丢失，合理设置重试逻辑，避免误判连接状

心跳与重连
- **重连策略**：当检测到心跳失败后，客户端应实施重连策略，如指数退避（每次尝试间隔时间逐渐增加）以避免对服务器造成冲击。
- **重连次数限制**：通常会设定最大重连次数，超过后停止重试，交由应用层处理或提示用户。


# 面试题

### GET和POST区别
`GET`方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据

`POST`方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或**副作用**

区别
- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中


### 地址栏输入URL敲下回车之后发生了什么

- URL解析
  判断事一个合法的URL还是搜索内容
- DNS 查询
  先查看是否有dns缓存，如果有直接复用。
  没有就进行查询：有迭代查询，从本地域名服务器分别向根域名服务器（`.com .xxx`）、顶级域名服务器（`baidu.com`）、权限域名服务器查询`返回www.baidu.com对应的IP地址`
- TCP 连接
  三次握手
- HTTP 请求
  发送http请求
- 响应请求
  响应http请求
- 页面渲染

页面渲染过程：
- 解析HTML，`构建 DOM 树`
- 解析 CSS ，生成 CSS 规则树，`构建CSSOM树`
- 合并 DOM 树和 CSS 规则，生成 `render 树`
- `布局` render 树（ Layout / reflow ），负责各元素尺寸、位置的计算
- `绘制` render 树（ paint ），绘制页面像素信息
- 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上，`光栅化`
![](../工程化/Public%20Image/Webpack/Pasted%20image%2020240512194818.png)