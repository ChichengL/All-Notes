## 初窥——性能指标
性能优化主要指标：
1. 首次内容绘制 (First Contentful Paint，FCP)
2. 最大内容绘制 (Largest Contentful Paint，LCP)
3. 首次输入延迟 (First Input Delay ，FID)
4. 交互到绘制延迟（Interaction to Next Paint，INP）
5. 累积布局偏移 (Cumulative Layout Shift，CLS)
6. 第一字节时间 (Time to First Byte，TTFB)

首次内容绘制：
**任意部分**DOM完成渲染的耗时，而非**全部**内容完成渲染耗时，不等于`onLoad`事件。
- 优：小于1.8秒
- 待改进：大于1.8秒且小于3秒
- 差：大于3秒

<hr>

最大内容绘制：
从页面开始加载到可视区域内**尺寸最大**的文字或图像渲染完成的耗时。
- 优：小于2.5秒
- 待改进：大于2.5秒且小于4秒
- 差：大于4秒

<hr>

首次输入延迟：
用户首次交互（点击、触摸）后到浏览器开始响应之间的时间间隔。
- 优：小于100毫秒
- 待改进：大于100毫秒且小于300毫秒
- 差：大于300毫秒

<hr>

交互到绘制延迟：
在页面浏览过程中的所有交互（点击、键盘输入、触摸等）与浏览器渲染响应的**整体**延迟情况。
- 优：小于200毫秒
- 待改进：大于200毫秒且小于500毫秒
- 差：大于500毫秒

<hr>

累计布局偏移：页面中所有**意外**布局变化的累计分值。（ps：无单位，浮点数）
比如某些你想点击关闭按钮突然，按钮因为布局被挤到另一边，导致点击到广告。
- 优：小于0.1
- 待改进：大于0.1且小于0.25
- 差：大于0.25

<hr>

第一字节时间：
前端页面（Document）的HTTP请求发送后，到接收到第一字节数据响应的耗时，通常包括重定向、DNS查询、服务器响应延迟等耗时。
- 优：小于800毫秒
- 待改进：大于800毫秒且小于1800毫秒
- 差：大于1800毫秒

这些指标可以通过`web-vitals`库获取，
```html
html复制代码<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>获取 web-vitals 数据 DEMO</title>
</head>
<body>
  <h2 id="fcp">FCP:</h2>
  <h2 id="lcp">LCP:</h2>
  <h2 id="ttfb">TTFB:</h2>
  <p>首次交互（例如：点击任意位置）后可获取：</p>
  <h2 id="fid">FID:</h2>
  <p>页面可视化状态变化为隐藏（例如：切换标签页）后可获取：</p>
  <h2 id="inp">INP:</h2>
  <h2 id="cls">CLS:</h2>
  
  
  <a href="https://github.com/JuniorTour">Author: https://github.com/JuniorTour</a>
  
  <script type="module">
    import {onFCP, onLCP, onFID, onCLS, onINP, onTTFB} from 'https://unpkg.com/web-vitals@3?module';

    function setInnerHtml(id, html) {
      if (!id || !html) {
        return
      }
      const el = document.querySelector(`#${id}`)
      if (el) {
        el.innerHTML = html
      }
    }
    
    function onGetWebVitalsData(data) {
      console.log(data)
      if (!data?.name) {
        return
      }
      const name = data.name
      const value = data.value
      const rating = data.rating
      const msg = (`${name}: value=${value}, rating=${rating}`)
      console.log(msg)
      setInnerHtml(name?.toLowerCase(), msg)
    }
    
    onFCP(onGetWebVitalsData);
    onLCP(onGetWebVitalsData); 
    onFID(onGetWebVitalsData); 
    onCLS(onGetWebVitalsData);
    onINP(onGetWebVitalsData);
    onTTFB(onGetWebVitalsData);
  </script>

</body>
</html>
```


## 初窥——收集数据
`web-vitals`虽然能观测到一系列指标，但是大多数时候只是在开发环境的观测，那么这种观测：样本总量较少，数据没有广泛代表性。

因此通常需要在生产环境中收集广大用户的真实数据，比较好用的工具有：Prometheus 和 Grafana。

[Prometheus](https://prometheus.io/) 是一款开源的数据监控解决方案，主要包括以下模块：

- 面向各种编程语言的数据采集SDK（例如面向 Node.js 的NPM包客户端：[prom-client](https://www.npmjs.com/package/prom-client)）
- 接收数据上报的服务器后端应用
- 基于时间序的数据库
- 基础的数据可视化前端应用

具有强大的拓展能力，可以方便快速地融合进已有的项目中，作为数据监控中台的工具使用。

[Grafana](https://link.juejin.cn/?target=https%3A%2F%2Fgrafana.com%2F) 是一款开源的数据可视化工具，主要有以下特性：

- 兼容 Prometheus 在内各种数据库的数据查询工具
- 内置海量可视化图表模板的前端应用
- 支持免费的私有化部署

接入示范（因为Grafana是免费的就这个做示范

- Grafana 官方的云端应用
- 本地环境自建的 Node.js 服务器应用
- Node.js 的 Prometheus 数据收集SDK：`prom-client`

注册：[Grafana](https://grafana.com/get/)
 >如果只需要指标收集和存储，建议选择 Prometheus 或 Graphite；
>
> 如果需要结合服务端日志进行分析，对日志中包含的数据做可视化，建议选择 Elasticsearch




## 预处理
优化方案1.
通过浏览器的各个api标明资源**优先级提示**

主要的有四个api
1. 预取回 Prefetch
2. 预加载 Preload
3. 预连接 Preconnect
4. DNS预取回 DNS-Prefetch

### 预取回Prefetch
预取回提示用于提示浏览器在CPU和网络带宽空闲时，**预先下载**指定URL的JS，图片等各类资源，存储到浏览器本地缓存中，从而减少该资源文件后续加载的耗时，从而优化用户体验。
`rel`属性设为`prefetch`，并将`href`属性设为**目标资源URL**
使用：
`<link rel="prefetch" href="https://github.com/JuniorTour/juniortour.js" />`
该标签插入DOM后，将触发一次`href`属性值对应URL的HTTP请求，并将响应保存到本地的`prefetch cache`中，但是并不会进一步解析、运行该资源。

命中预取回缓存的请求，在开发者工具中的`Network`标签中的`Size`列，会有独特的`(prefetch cache)`标记


`crossorigin`
`crossorigin`属性是浏览器同源策略的相关API，用于对`link`、`script`和`img`等元素指定以何种`跨域资源共享模式`加载目标资源。
 第三方JS文件可以访问第一方网站的错误上下文，从而获取内部信息。
- 第三方资源的源服务器可以在HTTP请求过程中通过SSL握手验证、`cookies`等手段获取用户身份信息。

为了缓解这些安全风险，浏览器引入了可用于`link`、`script`和`img`元素的`crossorigin`属性，对于这些元素加载的资源指定3类`跨域资源共享模式`，分别是：

- 没有`crossorigin`属性：无法获取 JS 的错误上下文，也不会在SSL握手阶段附带Cookies等用户身份相关的信息。
- 将`crossorigin`值设置为`"anonymous"`：可以访问JavaScript的错误上下文，但在请求过程中的SSL握手阶段不会携带cookies或其他用户凭据。
- 将`crossorigin`值设置为`"use-credentials"`：既可以访问JavaScript的错误上下文，也可以在请求过程中的SSL握手阶段携带Cookies或用户凭据。

对于跨域资源，则其资源优先级提示也需要设置为跨域，即`crossorigin="anonymous"`，例如：`<link rel="prefetch" href="https://github.com/JuniorTour/juniortour.js" crossorigin="anonymous" />`

### 预加载Preload
与预取回不同，预加载用于提高**当前**页面中资源加载的优先级，确保关键资源优先加载完成。
预加载最常见的用法是用于字体文件，减少因字体加载较慢导致的文字字体闪烁变化。例如：`<link rel="preload" as="font" href="/main.woff" />`
应用了`preload`提示的资源，通常会以较高的优先级**率先**在网页中加载，例如下图中的`nato-sans.woff2`请求，`Priority`列的值为`High`，加载顺序仅次于`Document`本身，能让字体较早在页面中渲染生效。
> `as`属性是必填属性，是`link`标签带有`rel="preload"`属性时，确定不同类型资源优先级的依据。
![](../Pasted%20image%2020240721164154.png)


### 预连接Preconnect
预连接提示用于提前与目标域名握手，完成DNS寻址，并建立TCP和TLS链接。

具体使用方式是将`link`标签的`rel`属性设为`preconnect`，并将`href`属性设为目标**域名**，例如 `<link rel="preconnect" href="https://github.com" />`。
优化效果是通过提前完成DNS寻址、建立TCP链接和完成TLS握手，从而减少后续访问目标域名时的连接耗时，改善用户体验。

**注意！** 强烈建议只对**重要域名**进行`Preconnect`优化，数量不要超过 6 个。
>1. **资源消耗**：每一个预连接都会立即发起DNS解析、TLS握手和TCP连接建立，这些操作都会消耗计算资源和网络带宽。如果预连接的域名过多，可能会导致不必要的资源浪费，特别是在移动设备或低带宽网络环境中，这种消耗更加明显。  
>2. **性能优化的权衡**：预连接是为了加速关键资源的加载，但如果对所有资源的域名都进行预连接，那么可能反而会因为资源的过早消耗而降低整体性能。浏览器的资源调度算法会试图优化加载顺序，如果太多资源被提前加载，可能会干扰这一过程，导致非关键资源抢占了关键资源的带宽和处理能力。

因为`Preconnect`生效后，会与目标域名的保持至少10秒钟的网络连接，占用设备的网络和内存资源，甚至阻碍其他资源的加载。


### DNS预取回DNS-Prefetch
与上文的预取回Prefetch不同，DNS预取回用于对**目标域名**提前进行DNS寻址，取回并缓存域名对应的IP地址，而非像预取回Prefetch那样缓存文件资源。

具体使用方式是将`link`标签的`rel`属性设为`dns-prefetch`，并将`href`属性值设为**目标域名**，例如 `<link rel="dns-prefetch" href="https://github.com" />`。

优化效果是通过提前解析出目标域名的IP地址，从而减少后续从目标域名加载资源的耗时，加快页面加载速度，改善用户体验。
这里只是将DNS预解析，不会进行`TLS握手和TCP连接`，**将域名映射为对应的ip**，有利有弊，虽然相比Preconnect消耗资源更少，但是不如Preconnect优化全面。
```html
<link rel="preconnect" href="static.juniortour.com" />
<link rel="dns-prefetch" href="static.juniortour.com" />
```
就能观察到网页中懒加载触发时，对目标域名的JS、CSS等资源加载耗时会显著减少。因为预连接 Preconnect 的生效使得资源加载时的DNS寻址、SSL握手等阶段得以提前进行，各资源加载时的总耗时就大幅减少，产生了显著的优化效果。

> DNS预取回的能力与预连接Preconnect有所重合，这是因为以往`dns-prefetch`的`浏览器兼容性`略好于`preconnect`，往往两者一同使用。
>
> 但近年来，IE被废弃，用户大都已使用更新版本的现代浏览器，兼容性不再重要，单独使用`preconnect`即可替代`dns-prefetch`。
四者差异

| 类型                  | 优化目标                         | 示例                                                            | 注意事项                                                                                                                                                                                                                     |
| ------------------- | ---------------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 预取回 Prefetch        | - 加载优先级较低的资源 - 后续页面浏览需要加载的资源 | `<link rel="prefetch" href="/juniortour.js" />`               | 1. Prefetch 预取回的资源并不会被立刻解析、运行：例如预取回JS文件时，JS文件内的代码逻辑并不会执行，只是文件保存到了浏览器缓存中。 这也是Prefetch与普通 link 标签（`<link href="/static/main.3da2f.css" rel="stylesheet">`）的核心区别。 2. Prefetch 的触发时机不固定，会由浏览器相机决定，浏览器通常会在网络带宽、CPU运算都空闲时触发下载。 |
| 预加载 Preload         | - 当前页面需要优先加载的静态资源            | `<link rel="preload" as="font" href="/main.woff" />`          | - 优化目标为当前页面所需资源，而非后续加载。                                                                                                                                                                                                  |
| 预连接 Preconnect      | - 加载优先级较低的域名 - 后续页面浏览需要连接的域名 | `<link rel="preconnect" href="<https://juniortour.net>" />`   | - 用于跨域域名，同源域名不需要 - 控制只对关键域名应用，避免数量超过6个                                                                                                                                                                                   |
| DNS预取回 DNS-Prefetch | - 后续页面浏览需要连接的域名              | `<link rel="dns-prefetch" href="<https://juniortour.net>" />` | （同预连接 Preconnect）                                                                                                                                                                                                        |


