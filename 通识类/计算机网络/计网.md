

# DNS
DNS是域名系统，其作用是：将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的IP 地址。
比如www.baidu.com为主机名。但是要说他的IP地址又有几个人知道呢？
虽然IP方便传输数据，但是不方便记忆，因此出现了DNS


DNS同时使用TCP和UDP协议
**DNS占用53号端口，同时使用TCP和UDP协议。**
（1）在区域传输的时候使用TCP协议
- 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
- TCP是一种可靠连接，保证了数据的准确性。


（2）在域名解析的时候使用UDP协议
- 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，`用UDP传输即可`。不用经过三次握手，`这样DNS服务器负载更低，响应更快`。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

DNS的完整流程
- 首先会在**浏览器的缓存**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
- 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
- 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
- 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
- 本地DNS服务器将返回结果保存在缓存中，便于下次使用
- 本地DNS服务器将返回结果返回给浏览器

DNS解析
DNS解析是一个包含迭代查询和递归查询的过程
- `递归查询`：是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。
- `迭代查询`：是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。


# TCP和UDP




其区别

|        |                        |                            |
| ------ | ---------------------- | -------------------------- |
|        | UDP                    | TCP                        |
| 是否连接   | 无连接                    | 面向连接                       |
| 是否可靠   | 不可靠传输，不使用流量控制和拥塞控制     | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信  | 只能是一对一通信                   |
| 传输方式   | 面向报文                   | 面向字节流                      |
| 首部开销   | 首部开销小，仅8字节             | 首部最小20字节，最大60字节            |
| 适用场景   | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输        |

应用：
TCP：效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

UDP：效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。


小Tips，TCP保证数据可靠采用了以下机制
>1. `序列号和确认应答`，TCP为每个发送的数据包分配一个序列号，接收方会对收到的数据包发送带有确认序列号的ACK响应。
>2. `超时重传`：如果发送方在预期时间内没有收到特定数据包的确认，它将认为该数据包丢失或损坏，并重新发送该数据包。TCP实现中使用了重传计时器来检测超时事件。
>3. `检验和`：TCP头包含一个校验和字段，用于检测数据在传输过程中是否受损。接收方对接收到的数据进行校验，如果`校验和不匹配，则数据包被丢弃`，并通过不发送ACK来触发发送方重传。
>4. `流量控制`：TCP使用滑动窗口协议来控制数据的发送速率，以避免拥塞和数据丢失。接收方会告知发送方其接收缓冲区的可用空间大小，发送方据此调整发送速率，从而避免数据发送过快导致接收方无法处理。
>5. `拥塞控制`：TCP根据网络状况动态调整其发送速率，以避免网络拥塞。当网络开始出现拥塞迹象时，TCP会减少其数据的发送速率，使用`慢启动、拥塞避免`、快速重传和快速恢复等算法来管理数据流。
>6. `连接管理`：TCP使用三次握手建立连接，确保双方都准备好进行通信，并使用四次挥手断开连接，确保数据的有序关闭，且双方都确认没有更多数据待发送。
>
>   三次握手
>   ![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663256-5eb6dcdf-fdb6-4b67-a3da-da15c1d396fb.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_680%2Climit_0)
>   采用三次握手的原因，如果采用二次握手会怎么办
>   >如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。
>   总结：TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。` 第三次握手的作用是客户端对服务器端的初始序号的确认`。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。
>   
>   四次挥手
>   ![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663279-0ea063ba-a06b-4f57-9aa9-0e2d1c8d373c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_19%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_680%2Climit_0)
>   采用四次挥手的原因
>   >因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。
>   TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。
>   最后一次挥手中，客户端会等待一段时间再关闭的原因，`是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。`
>![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952153-a7106d22-225d-4081-9b0a-56b0d1876bc2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_750%2Climit_0)

## 面试题
### TCP三次握手分别处于的状态
1. **第一次握手**：
	    客户端：closed->syn_sent,服务端listen->syn_send
    - 客户端状态从 `CLOSED` 转变为 `SYN_SENT`，并向服务器发送一个SYN（同步序列编号，Synchronize）标志的包，请求建立连接。
    - 服务器状态从 `LISTEN` 转变为 `SYN_RECV`，接收到客户端的SYN后，向客户端发送一个SYN+ACK（确认）的包，确认客户端的SYN并且请求客户端确认。
2. **第二次握手**：
	    客户端:syn_sent->established，服务端:维持syn_send
    - 客户端接收到服务器的SYN+ACK包后，状态从 `SYN_SENT` 转变为 `ESTABLISHED`（连接已建立），并向服务器发送一个ACK（确认）包，确认收到了服务器的SYN。
    - 服务器维持在 `SYN_RECV` 状态，等待客户端的ACK。
3. **第三次握手**：
	    服务端：syn_send->establish
    - 服务器接收到客户端的ACK后，状态从 `SYN_RECV` 转变为 `ESTABLISHED`。
    - 此时，客户端和服务器都处于 `ESTABLISHED` 状态，连接建立完成。
### 为什么不采用两次握手
两次握手无法确保客户端发送的连接请求没有在网络中滞留，如果只进行两次握手，服务器发出的SYN+ACK响应可能因为网络问题丢失，而服务器会误以为连接已建立并等待客户端的数据传输，导致服务器资源被无谓占用。三次握手通过客户端的最后确认，确保了服务器不会因历史残留的请求而等待一个并不存在的连接。

### TCP四次挥手服务端和客户端的状态
1. **第一次挥手**：
	    客户端：fin_wait_1 ，服务端：close_wait
    - 客户端打算关闭连接，发送一个FIN（Finish）标志的包，进入 `FIN_WAIT_1` 状态，告诉服务器它将不再发送数据。
    - 服务器接收到FIN包后，回复一个ACK确认，服务器状态变为 `CLOSE_WAIT`，此时服务器仍可以向客户端发送数据。
2. **第二次挥手**：
	    客户端：fin_wait_2 ，服务端：last_ack
    - 当服务器准备好关闭连接时，向客户端发送FIN包，服务器状态变为 `LAST_ACK`。
    - 客户端接收到服务器的FIN包后，向服务器发送ACK确认，进入 `FIN_WAIT_2` 状态。
3. **第三次挥手**：
	    服务端：close
    - 服务器接收到客户端的ACK后，连接关闭，状态变为 `CLOSED`。
4. **第四次挥手**：
	    客户端：fin_wait_2 -> time_wait -> closed
    - 客户端等待一段时间（确保所有数据包都被服务器接收），如果没有数据需要接收，则最终也会关闭连接，状态从 `FIN_WAIT_2` 变为 `TIME_WAIT`，经过2MSL时间后变为 `CLOSED`。
### 为什么不采用三次挥手（这里是把2,3次合并在一起）
这里是为了让资源完整发送到对面且正确处理
**四次挥手未正确处理的风险**
1. ​**资源泄漏**：
    - 若未正确关闭连接，服务器或客户端可能积累大量 `CLOSE_WAIT` 状态连接，最终耗尽资源（如文件描述符）。
    - ​**案例**：Nginx 服务器出现 `CLOSE_WAIT` 激增，通常因代码未正确调用 `close()`。
2. ​**数据不完整**：
    - 被动关闭方在 `CLOSE_WAIT` 状态未发送完数据就关闭连接，导致客户端收不到完整响应。


### 为什么四次挥手要等2msl
客户端在发送完最后一个ACK之后，会进入 `TIME_WAIT` 状态，等待2MSL（Maximum Segment Lifetime，最大报文生存时间）时间。这是为了确保最后一个ACK能够到达服务器，以及网络中任何可能滞留的重复分组（如服务器发送的FIN）完全消失，避免新旧连接混淆。
如果没有四次挥手没有到达，可以通过超时重传进行重新传输报文




# 网络模型
### OSI七层模型（Open System Interconnection Model）

OSI模型是一种理论性的、分层的网络通信协议体系结构，由国际标准化组织（ISO）制定。它将网络通信的功能分为七个层次，从下到上分别为：

1. **物理层（Physical Layer）**：负责原始比特流的传输，定义了网络设备之间物理连接的规格，如电压、线缆类型、接口形状等。
2. **数据链路层（Data Link Layer）**：在此层，数据被分成帧（frames），并处理错误检测和纠正，以及访问介质的方法（如以太网）。
3. **网络层（Network Layer）**：负责将数据包从源节点路由到目的节点，主要的协议有IP（Internet Protocol）。
4. **传输层（Transport Layer）**：提供端到端的可靠或不可靠的数据传输服务，包括TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）。
5. **会话层（Session Layer）**：管理会话的建立、维护和终止，以及同步点。
6. **表示层（Presentation Layer）**：处理数据的表现形式，如加密、解密、压缩、解压缩等。
7. **应用层（Application Layer）**：为应用程序提供网络服务接口，如HTTP、FTP、SMTP等。

### TCP/IP四层模型

TCP/IP模型是互联网实际采用的模型，相比OSI模型更为简化实用，分为四个层次：

1. **网络接口层（Network Interface Layer）**：对应OSI的物理层和数据链路层，负责实际的物理连接和数据传输。
2. **网络层（Internet Layer）**：相当于OSI的网络层，主要协议是IP，负责地址分配和数据包的路由。
3. **传输层（Transport Layer）**：与OSI的传输层相对应，包含TCP和UDP，负责端到端的通信和错误检测。
4. **应用层（Application Layer）**：合并了OSI的会话层、表示层和应用层，支持各种高层协议，如HTTP、FTP、SMTP等。

### 通用五层模型

通用五层模型是教育和实践中常用的一种折中模型，它结合了OSI和TCP/IP模型的特点，分为五个层次：

1. **物理层**：与OSI相同。
2. **数据链路层**：与OSI相同。
3. **网络层**：与OSI相同。
4. **传输层**：与OSI相同。
5. **应用层**：合并了OSI的会话层、表示层和应用层的功能，提供最终用户服务。