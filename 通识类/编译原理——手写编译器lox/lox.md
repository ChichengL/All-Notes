## 语言的组成
### 词法分析
对于一门语言来说首先是会进行
比如
```js
var avg = min + max >> 1;
```
![lox- toekn](lox-%20toekn.md)
### 解析
用一个个token组成更大的部分，比如ast
解析是把词法分析得到的 token 序列转化为抽象语法树（AST）。AST 是代码的一种树形表示，它体现了代码的语法结构。
```
VariableDeclaration
├── kind: "var"
├── declarations
│   └── VariableDeclarator
│       ├── id: Identifier (name: "avg")
│       └── init: BinaryExpression
│           ├── operator: ">>"
│           ├── left: BinaryExpression
│           │   ├── operator: "+"
│           │   ├── left: Identifier (name: "min")
│           │   └── right: Identifier (name: "max")
│           └── right: Literal (value: 1)
```
## 静态分析
分析表达式语法等，
静态分析是在不运行代码的情况下对代码进行分析，像类型检查、作用域分析等都属于静态分析
- 类型检查，比如检查max ,min是否是数字类型
- 作用域分析，分析当前变量是在局部作用域还是全局作用域
还有语法等等，通过编译器静态分析代码是否存在语法等错误
### 中间表示
中间表示（IR）是介于源代码和目标代码之间的一种表示形式，它独立于具体的编程语言和目标机器。

对于 `var avg = min + max >> 1;`，中间表示可能类似如下伪代码：
```
t1 = add(min, max)
t2 = shift_right(t1, 1)
avg = t2
```

### 优化
优化是对中间表示或者目标代码进行改进，以提高代码的性能和效率。
比如：
- 常量折叠
	若 `min` 和 `max` 是常量，编译器可以在编译时就计算出 `min + max >> 1` 的结果。
-  公共子表达式消除
	如果在代码里多次出现 `min + max >> 1`，编译器可以只计算一次，然后复用结果。
### 代码生成
代码生成是把中间表示转化成目标机器能够执行的机器代码或者字节码。
在 JavaScript 引擎中，最终会生成能够在 V8 等引擎上执行的字节码或者机器码。


### 虚拟机
如果是编译器生成字节码，虚拟机将字节码转化为对应的机器码。（比如java，这样子可以实现跨平台调用一套代码）

### 运行
将代码运行在vm或者解释器中


## 捷径 or 替代方案

### 单通道编辑器
一些简单的编译器将解析、分析和代码生成交错在一起，以便它们直接在解析器中生成输出代码，而无需分配任何语法树或其他 IR 的 API 中。这些单通道编译器限制了语言。
这个是一次性构建的

### 转译器
目前很多高级语言都有转译器。比如ts->js

| 特性       | 编译器                | 转译器                     |
| -------- | ------------------ | ----------------------- |
| **目标输出** | 低级代码（机器码、字节码）      | 高级代码（同层或另一种高级语言）        |
| **典型场景** | Java → 字节码，C → 机器码 | TypeScript → JavaScript |
| **核心目标** | 性能优化、平台适配          | 兼容性、语法转换、DSL 支持         |

### 即时编译
jit in time compilation
比如现代js引擎就利用了jit的技术
例如，V8 引擎会将 JavaScript 代码先编译成中间字节码，然后在运行时将热点代码进一步编译成机器码。

其核心：
- **解释执行**：程序开始运行时，通常采用解释器逐行解释执行代码。解释器读取字节码或中间表示，然后直接执行相应的操作。这种方式的优点是启动速度快，不需要提前编译整个程序，但执行效率相对较低。
- **热点代码检测**：在解释执行过程中，即时编译器会监控代码的执行情况，统计每个代码块的执行次数。当某个代码块的执行次数达到一定阈值时，就会被认定为热点代码。常见的热点代码包括循环体、频繁调用的函数等。
- **编译优化**：一旦检测到热点代码，即时编译器会将该代码块编译成机器码。在编译过程中，即时编译器会进行一系列的优化操作，如常量折叠、公共子表达式消除、方法内联等，以生成高效的机器码
- **机器码执行**：编译完成后，程序会直接执行生成的机器码，而不是继续解释执行字节码。由于机器码可以直接在硬件上执行，因此执行效率会显著提高。
#### 题外话JS 引擎的JIT
目前的js可以理解为解释型语言，**编译为主，解释为辅**。

reason: 是因为现代js引擎。js引擎的变化过程：
- full-codegen：将全部代码直接编译为机器码，内存开销大
- ignnition + turboFan：Ignition：
	- 生成字节码并解释执行，记录热点
	- TurboFan: 将热点字节码编译为高度优化的机器码（如内联缓存、类型特化）。
	- 数据对比：TurboFan 生成的机器码执行速度是 Ignition 的 10-100 倍（实测循环密集型代码）
- 反优化（兜底）：若优化假设失效（如函数参数类型变化），机器码回退为字节码，由解释器执行。但反优化是例外，而非常态。
执行流程：
1. 解析：将源代码转换为抽象语法树（AST），并生成中间表示（如 V8 的 **Bytecode** 或 SpiderMonkey 的 **Baseline Code**）。
2. 解释执行：初始阶段通过解释器（如 V8 的 **Ignition**）逐行执行字节码。解释执行的启动速度快，但效率较低。
3. 热点代码检测与JIT编译：引擎监控代码执行频率，当某段代码（如循环、高频函数）成为 “热点代码” 时，即时编译器（如 V8 的 **TurboFan**）将其编译为机器码（Native Code）。机器码的执行效率远高于解释执行。
4. 优化和反优化：JIT 编译时会进行激进优化（如内联、类型特化），但若优化假设不成立（如类型变更），引擎会回退到解释执行（反优化）。**反优化，类似于默认的兜底策略**

| 维度         | 编译型语言（如 C++） | 传统解释型语言（如早期 JS） | 现代 JavaScript（如 V8）       |
|--------------|----------------------|----------------------------|-------------------------------|
| **编译时机** | 提前编译（AOT）      | 无编译（纯解释）           | 运行时编译（JIT + 解释）       |
| **执行主体** | 机器码              | 解释器执行                 | **机器码（热点）+ 字节码（非热点）** |
| **性能核心** | 静态优化            | 无优化                     | **JIT 动态优化（如内联、类型特化）** |

## 编译器和解释器
![](image/Pasted%20image%2020250324003657.png)


# Lox语言——起始
## 语言特性
- 动态类型，如js
- 自动内存管理（自动gc）
- 数据类型
	- bool，只分真假
	- number：双浮点数字包含整数和浮点数，且精度足够
	- string：双引号（和char区分）
	- char：单引号
	- Nil：no value
- 表达式：
	- 算术：
		+ - *  /
		+ 二元运算符 **?:**
	+ 比较和相等：<、<=、>、>=、**= =** 相等
	+ 逻辑运算符：使用and 和or代替 || &&，同时不引入按位运算符
	+ 优先级和分组
	+ 语句
	+ 变量
		+ 默认值：Nil
		+ var声明
	+ 控制流
		+ if-else
		+ for-in
		+ while
	+ 函数
		+ 如果函数没有返回，那么隐式返回Nil
		+ 闭包
	+ class
		+ oop，面向对象
		+ 原型
		+ 类
		+ 初始化和实例化
		+ 继承
```
class Breakfast {
  cook() {
    print "Eggs a-fryin'!";
  }
  init(meat, bread) {
    this.meat = meat;
    this.bread = bread;
  }

  serve(who) {
    print "Enjoy your breakfast, " + who + ".";
  }
}
var baconAndToast = Breakfast("bacon", "toast");
baconAndToast.serve("Dear Reader");
// 继承
class Brunch < Breakfast {
  init(meat,bread,drink){
	  super.init(meat,bread);
	  this.drink = drink;
  }
  drink() {
    print "How about a Bloody Mary?";
  }
}
```

